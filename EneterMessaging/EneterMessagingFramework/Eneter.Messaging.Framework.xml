<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eneter.Messaging.Framework</name>
    </assembly>
    <members>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1">
            <summary>
            Memory message queue.
            </summary>
            <remarks>
            One or more threads can put messages into the queue and other threads
            can remove them.
            If the queue is empty the thread reading messages is blocked until a message
            is put to the queue or the thread is unblocked.
            </remarks>
            <typeparam name="TMessage">Type of the message.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.EnqueueMessage(`0)">
            <summary>
            Puts message to the queue.
            </summary>
            <param name="message">message that shall be enqueued</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.DequeueMessage">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <returns>message, it returns null if the waiting thread was unblocked but there is no message in the queue.</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.PeekMessage">
            <summary>
            Reads the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <returns>
            message, it returns null if the waiting thread was unblocked but there is no message in the queue.
            </returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.DequeueMessage(System.Int32)">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked until the specified timeout.
            The method UnblockProcesseingThreads() unblocks threads waiting in this method.
            </summary>
            <param name="millisecondsTimeout">Maximum waiting time for the message. If the time is exceeded the TimeoutException is thrown.</param>
            <returns>message</returns>
            <exception cref="T:System.TimeoutException">when the specified timeout is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.PeekMessage(System.Int32)">
            <summary>
            Reads the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <param name="millisecondsTimeout">
            Maximum waiting time for the message. If the time is exceeded the TimeoutException is thrown.
            </param>
            <returns>message</returns>
            <exception cref="T:System.TimeoutException">when the specified timeout is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.Clear">
            <summary>
            Deletes all items from the message queue.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.UnblockProcessingThreads">
            <summary>
            Releases all threads waiting for messages in DequeueMessage() and sets the queue to the unblocking mode.
            </summary>
            <remarks>
            When the queue is in unblocking mode, the dequeue or peek will not block if data is not available but
            it will return null or default values.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.BlockProcessingThreads">
            <summary>
            Sets the queue to the blocking mode.
            </summary>
            <remarks>
            When the queue is in blocking mode, the dequeue and peek will block until data is available.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.IsBlockingMode">
            <summary>
            Returns true if the queue blocks threads during dequeue and peek.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.Count">
            <summary>
            Returns number of messages in the queue.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.WaitForQueueCall(System.Func{`0})">
            <summary>
            Waits until something is in the queue and then calls the specified delegate.
            If the waiting thread is released (by UnblockProcessingThreads) but the queue is still empty, it returns the default
            value of the specified template type.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.myMessageQueue">
            <summary>
            Queue for messages.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.myIsBlockingMode">
            <summary>
            Indicates weather the reading from the queue blocks until data is available.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1">
            <summary>
            Thread with the message queue.
            </summary>
            <remarks>
            If a message is put to the queue, the thread removes it from the queue and calls a call-back
            method to process it.
            </remarks>
            <typeparam name="TMessage">type of the message processed by the thread</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.RegisterMessageHandler(System.Action{`0})">
            <summary>
            Registers the handler processing messages.
            </summary>
            <param name="messageHandler"></param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.UnregisterMessageHandler">
            <summary>
            Unregisters the handler processing messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.EnqueueMessage(`0)">
            <summary>
            Enqueues the message to the queue.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.NamespaceDoc">
            <summary>
            Helper to queue and process messages with a working thread.
            </summary>
            <remarks>
            Several threads can put messages to the queue and one thread removes them and calls a call-back method to process them.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.AesSerializer">
            <summary>
            Serializer using AES (Advanced Encryption Standard).
            </summary>
            <remarks>
            The serializer uses an underlying serializer to serialize and deserialize data.
            Data encoded by the underlying serializer is then encrypted by AES.
            <example>
            Encrypted serialization with <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>
            <code>
            // Create the serializer. The defualt constructor uses XmlStringSerializer.
            AesSerializer aSerializer = new AesSerializer("My password.");
            
            // Create some data to be serialized.
            MyData aData = new MyData();
            ...
            
            // Serialize data with using AES.
            object aSerializedData = aSerializer.Serialize&lt;MyData&gt;(aData);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String)">
            <summary>
            Constructs the serializer. It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/> as the underlying serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate the key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="keyBitSize">bit size of the key e.g. 128, 256</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Security.Cryptography.DeriveBytes,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="passwordBasedKeyGenerator">generator of key from the password</param>
            <param name="keyBitSize">bit size of the key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.Byte[],System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="key">key</param>
            <param name="iv">initialization vector</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Returned bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer">
            <summary>
            Serializes data into .NET specific byte sequence.
            </summary>
            <remarks>
            The serializer internally uses BinaryFormatter provided by .Net.
            The data is serialized in the binary format.
            <example>
            Serialization and deserialization example.
            <code>
            // Some class to be serialized.
            [Serializable]
            public class MyClass
            {
                public int Value1 { get; set; }
                public string Value2 { get; set; }
            }
            
            ...
            
            MyClass c = new MyClass;
            c.Value1 = 10;
            c.Value2 = "Hello World.";
            
            ...
            
            // Serialization
            BinarySerializer aSerializer = new BinarySerializer();
            object aSerializedObject = aSerializer.Serialize&lt;MyClass&gt;(c);
            
            ...
            
            // Deserialization
            BinarySerializer aSerializer = new BinarySerializer();
            object aDeserializedObject = aSerializer.Deserialize&lt;MyClass&gt;(aSerializedObject);
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer.#ctor">
            <summary>
            Constructs the binary serializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer.#ctor(System.Boolean)">
            <summary>
            Constructs the binary serializer with a possibility to enforce deserialization into desired type.
            </summary>
            <remarks>
            If the input parameter is false then if the assembly and the namespace of deserialized type does not match with
            the assembly and the namespace of serialized data the exception is thrown.
            If the input parameter is true then the deserialized type does not have to be from the same assembly and the namespace.<br/>
            The defaulat setting is false.
            </remarks>
            <param name="enforceTypeBinding"></param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the sequnce of bytes, byte[].
            </summary>
            <remarks>
            It internally BinaryFormatter provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <remarks>
            It internally BinaryFormatter provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">the sequence of bytes (byte[]), to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.CallbackSerializer">
            <summary>
            Place holder serializer which contains the callback for the serialization.
            </summary>
            <remarks>
            The serializer is used in cases where the serializer needs to be retrieved on demand based on response receiver id.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.CryptoSerializerProvider.Serialize``1(``0,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Output bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <param name="algorithm">algorithm used to encrypt the serialized data</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.CryptoSerializerProvider.Deserialize``1(System.Object,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <param name="algorithm">algorithm used to decrypt data before deserialization</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer">
            <summary>
            Serializes data to XML using the DataContractSerializer.
            </summary>
            <remarks>
            The serializer is based on DataContractSerializer provided by .Net and it supports
            attributes (DataContract, DataMember, ...) specifying how data is serialized/deserialized.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.#ctor">
            <summary>
            Creates the serializer based on DataContractSerializer with default settings.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.#ctor(System.Func{System.Type,System.Runtime.Serialization.XmlObjectSerializer})">
            <summary>
            Creates the serializer that allows user to specify his own method to instantiate DataContractSerializer
            with desired settings.
            </summary>
            <param name="dataContractFactoryMethod">
            The factory method responsible for creation of DataContractSerializer.
            The factory method is called during the serialization or deserialization.<br/>
            The factory method can be called from more threads at the same time, so be sure, your factory method
            is thread safe.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data serialized in xml string.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.GetSerializerCallback">
            <summary>
            Callback used by communication components to get serializer for a specific client connection.
            </summary>
            <param name="responseReceiverId">specifies the particular client connection</param>
            <remarks>
            If the callback is specified then the service communication component calls it whenever it needs to serialize/deserialize
            the communication with the client. The purpose of this callback is to allow to use for each client a different serializer.
            E.g. if the serialized message shall be encrypted by a client specific password or a key.
            </remarks>
            <returns>serializer</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer">
            <summary>
            Serializer compressing and decompressing data.
            </summary>
            <remarks>
            The serializer internally uses GZipStream to compress and decompress data.
            <example>
            Example shows how to serialize data.
            <code>
            // Creat the serializer.
            GZipSerializer aSerializer = new GZipSerializer();
            
            // Create some data to be serialized.
            MyData aData = new MyData();
            ...
            
            // Serialize data. Serialized data will be compressed.
            object aSerializedData = aSerializer.Serialize&lt;MyData&gt;(aData);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.#ctor">
            <summary>
            Constructs the serializer with XmlStringSerializer as the underlying serializer.
            </summary>
            <remarks>
            The serializer uses the underlying serializer to serialize data before the compression.
            It also uses the underlying serializer to deserialize decompressed data.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer with the given underlying serializer.
            </summary>
            <remarks>
            The serializer uses the underlying serializer to serialize data before the compression.
            It also uses the underlying serializer to deserialize decompressed data.
            </remarks>
            <param name="underlyingSerializer">underlying serializer</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.Serialize``1(``0)">
            <summary>
            Serializes the given data with using the compression.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes compressed data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Compressed data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.ISerializer">
            <summary>
            Declares the serializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Serialize``1(``0)">
            <summary>
            Serializes data.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>
            Object representing the serialized data.
            Typically it can be byte[] or string.
            </returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer">
            <summary>
            Serializer using Rijndael encryption.
            </summary>
            <remarks>
            The serializer internally uses some other serializer to serialize and deserialize data.
            Then it uses Rijndael to encrypt and decrypt the data.
            <example>
            Encrypted serialization with <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>
            <code>
            // Create the serializer. The defualt constructor uses XmlStringSerializer.
            RijndaelSerializer aSerializer = new RijndaelSerializer("My password.");
            
            // Create some data to be serialized.
            MyData aData = new MyData();
            ...
            
            // Serialize data with using Rijndael.
            object aSerializedData = aSerializer.Serialize&lt;MyData&gt;(aData);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String)">
            <summary>
            Constructs the serializer. It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/> as the underlying serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate the key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="keyBitSize">bit size of the key e.g. 128, 256</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Security.Cryptography.DeriveBytes,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="passwordBasedKeyGenerator">generator of key from the password</param>
            <param name="keyBitSize">bit size of the key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Returned bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.RsaDigitalSignatureSerializer">
            <summary>
            Serializer digitaly signing data.
            </summary>
            <remarks>
            Serialization:
            <ol>
            <li>Incoming data is serialized by underlying serializer (e.g. XmlStringSerializer)</li>
            <li>SHA1 hash is calculated from the serialized data.</li>
            <li>The hash is encrypted with RSA using the private key.</li>
            <li>The serialized data consists of serialized data, encoded hash (signature) and public certificate of the signer.</li>
            </ol>
            Deserialization:
            <ol>
            <li>The public certificate is taken from serialized data and verified. (you can provide your own verification)</li>
            <li>SHA1 hash is calculated from serialized data.</li>
            <li>Encrypted hash (signature) is decrypted by public key taken from the certificate.</li>
            <li>If the decrypted hash is same as calculated one the data is ok.</li>
            <li>Data is deserialized by the underlying serializer and returned.</li>
            </ol>
            <example>
            Example shows how to serialize/deserialize data using digital signature.
            <code>
            // Get the certificate containing public and private keys. E.g. from the file.
            X509Certificate2 aSignerCertificate = new X509Certificate2("c:/MyCertificate.pfx", "mypassword");
            
            // Create the serializer.
            RsaDigitalSignatureSerializer aSerializer = new RsaDigitalSignatureSerializer(aSignerCertificate);
            
            // Serialize data.
            // (serialized data will contain digital signature and signer's public certificate)
            object aSerializedData = aSerializer.Serialize&lt;string&gt;("Hello world.");
            
            // Deserialize data.
            string aDeserializedData = aSerializer.Deserialize&lt;string&gt;(aSerializedData);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaDigitalSignatureSerializer.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Constructs the serializer with default parameters.
            </summary>
            <remarks>
            It uses XmlStringSerializer as the underlying serializer and it uses default X509Certificate2.Verify() method to verify
            the public certificate.
            </remarks>
            <param name="signerCertificate">signer certificate containing public and also private part.
            The key from the private part is used to sign data during the serialization.<br/>
            The public certificate is attached to serialized data.<br/>
            If the parameter signerCertificate is null then the serializer can be used only for deserialization.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaDigitalSignatureSerializer.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Func{System.Security.Cryptography.X509Certificates.X509Certificate2,System.Boolean},Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer with custom parameters.
            </summary>
            <param name="signerCertificate">signer certificate containing public and also private part.
            The key from the private part is used to sign data during the serialization.<br/>
            The public certificate is attached to serialized data.<br/>
            If the parameter certificate is null then the serializer can be used only for deserialization.
            </param>
            <param name="verifySignerCertificate">callback to verify the certificate. If null then default X509Certificate2.Verify() is used.</param>
            <param name="underlyingSerializer">underlying serializer that will be used to serialize/deserialize data</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaDigitalSignatureSerializer.Serialize``1(``0)">
            <summary>
            Serializes data.
            </summary>
            <typeparam name="_T">data type to be serialized</typeparam>
            <param name="dataToSerialize">data to be serialized</param>
            <returns>serialized data</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaDigitalSignatureSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data.
            </summary>
            <typeparam name="_T">data type to be deserialized</typeparam>
            <param name="serializedData">serialized data</param>
            <returns>deserialized data type</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.RsaSerializer">
            <summary>
            Serializer using RSA.
            </summary>
            <remarks>
            The serialization:
            <ol>
            <li>Incoming data is serialized by underlying serializer (e.g. XmlStringSerializer)</li>
            <li>The random key is generated and used with AES algorythm to encrypt the serialized data.</li>
            <li>The random key for AES is encrypted by RSA using the public key.</li>
            <li>The serialized data consits of AES encrypted data and RSA encrypted key for AES.</li>
            </ol>
            The deserialization:
            <ol>
            <li>The receiver decrypts the AES key by RSA using its private key.</li>
            <li>Decrypted key is used to decrypt AES encrypted data.</li>
            <li>Decrypted data is deserialized by underlying serialized (e.g. XmlStringSerializer)</li>
            <li>The deserialization returns deserialized data.</li>
            </ol>
            <br/>
            <example>
            Example shows how to serialize/deserialize data.
            <code>
            // Generate public and private keys.
            RSACryptoServiceProvider aCryptoProvider = new RSACryptoServiceProvider();
            RSAParameters aPublicKey = aCryptoProvider.ExportParameters(false);
            RSAParameters aPrivateKey = aCryptoProvider.ExportParameters(true);
            
            // Create the serializer.
            RsaSerializer aSerializer = new RsaSerializer(aPublicKey, aPrivateKey);
            
            // Serialize data.
            object aSerializedData = aSerializer.Serialize&lt;string&gt;("Hello world.");
            
            
            // Deserialize data.
            string aDeserializedData = aSerializer.Deserialize&lt;string&gt;(aSerializedData);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaSerializer.#ctor(System.Security.Cryptography.RSAParameters,System.Security.Cryptography.RSAParameters)">
            <summary>
            Constructs the RSA serializer with default paraneters.
            </summary>
            <remarks>
            It uses XmlStringSerializer and it will generate
            128 bit key for the AES algorythm.
            </remarks>
            <param name="publicKey">public key used for serialization. If the serializer is used only for deserialization then you can provide
            a dummy key e.g. new RSAParameters().
            </param>
            <param name="privateKey">private key used for deserialization. If the serializer is used only for serialization then you can provide
            a dummy key e.g. new RSAParameters().
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaSerializer.#ctor(System.Security.Cryptography.RSAParameters,System.Security.Cryptography.RSAParameters,System.Int32,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the RSA serializer with custom parameters.
            </summary>
            <param name="publicKey">public key used for serialization. If the serializer is used only for deserialization then you can provide
            a dummy key e.g. new RSAParameters().
            </param>
            <param name="privateKey">private key used for deserialization. If the serializer is used only for serialization then you can provide
            a dummy key e.g. new RSAParameters().
            </param>
            <param name="aesBitSize">size of the random key generated for the AES encryption, 128, 256, ...</param>
            <param name="underlyingSerializer">underlying serializer used to serialize/deserialize data e.g. XmlStringSerializer</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaSerializer.Serialize``1(``0)">
            <summary>
            Serializes data.
            </summary>
            <typeparam name="_T">data type to be serialized</typeparam>
            <param name="dataToSerialize">data to be serialized</param>
            <returns>serialized data</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data.
            </summary>
            <typeparam name="_T">data type to be deserialized</typeparam>
            <param name="serializedData">serialized data</param>
            <returns>deserialized data type</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.SerializerExt.Serialize(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Type,System.Object)">
            <summary>
            Serializes using Type instead of generics.
            </summary>
            <param name="serializer">serializer derived from ISerializer</param>
            <param name="dataType">type of serialized data</param>
            <param name="dataToSerialzier">data to be serialized</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.SerializerExt.Deserialize(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Type,System.Object)">
            <summary>
            Deserializes using Type instead of generics.
            </summary>
            <param name="serializer">serializer derived from ISerializer</param>
            <param name="dataType">type of deserialized data</param>
            <param name="serializedData">data to be deserialized</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer">
            <summary>
            Serializes data to XML (compatible with Java).
            </summary>
            <remarks>
            This is the default serializer used by the framework. The serializer is compatible
            with XmlStringSerializer from Eneter Messaging Framework for .NET.
            Therefore, you can use it for the communication between Java and .NET applications.
            <b>The serializer does not support generic types on Java and Android platforms!</b>
            <br/>
            The serializer internally uses XmlSerializer provided by .Net.
            <example>
            Serialization and deserialization example.
            <code>
            // Some class to be serialized.
            public class MyClass
            {
                public int Value1 { get; set; }
                public string Value2 { get; set; }
            }
            
            ...
            
            MyClass c = new MyClass;
            c.Value1 = 10;
            c.Value2 = "Hello World.";
            
            ...
            
            // Serialization
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            object aSerializedObject = aSerializer.Serialize&lt;MyClass&gt;(c);
            
            ...
            
            // Deserialization
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            object aDeserializedObject = aSerializer.Deserialize&lt;MyClass&gt;(aSerializedObject);
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.#ctor">
            <summary>
            Creates the serializer based on XmlSerializer with default settings.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.#ctor(System.Func{System.Type,System.Xml.Serialization.XmlSerializer})">
            <summary>
            Creates the serializer that allows user to specify his own method instantiating XmlSerializer
            with desired settings.
            </summary>
            <param name="xmlSerializerFactoryMethod">
            The factory method responsible for creation of XmlSerializer.
            The factory method is called during the serialization or deserialization.<br/>
            The factory method can be called from more threads at the same time, so be sure, your factory method
            is thread safe.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            </summary>
            <remarks>
            It internally XmlSerializer provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <remarks>
            It internally XmlSerializer provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.NamespaceDoc">
            <summary>
            Message serializers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.DynamicStream">
            <summary>
            Stream which can be written and read at the same time.
            </summary>
            <remarks>
            The dynamic stream supports writing of data by one thread and reading by another.
            The reading operation is blocked until the requested amount of data is not available.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.IsBlockingMode">
            <summary>
            Gets or sets the blocking mode. If blocking mode then Read method blocks until data is available.
            </summary>
            <remarks>
            If blocking mode then Read method blocks until data is available. If unblocking mode is set then
            Read method reads available data and returns. If a reading thread is blocked (waiting) and the unblocking mode
            is set the thread is released.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanRead">
            <summary>
            Returns true, because the stream supports reading.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanSeek">
            <summary>
            Returns false, because the stream does not support Seek.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanWrite">
            <summary>
            Returns true, because the stream supports writing.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Flush">
            <summary>
            The Flush is not applicable. If called, it does nothing.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Length">
            <summary>
            Returns always 0.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Position">
            <summary>
            'Get' returns always 0. Set does nothing.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            The stream does not support Seek.
            It throws NotSupportedException.
            </summary>
            <param name="offset">not applicable</param>
            <param name="origin">not applicable</param>
            <returns>not applicable</returns>
            <exception cref="T:System.NotSupportedException">
            </exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.SetLength(System.Int64)">
            <summary>
            The stream does not support SetLength.
            It throws NotSupportedException.
            </summary>
            <param name="value">not applicable</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads data from the stream to the specified buffer.
            </summary>
            <remarks>
            If the requested amount of data is not available the thread is blocked until required amount of data
            is available - until data is written by another thread.
            </remarks>
            <param name="buffer">The buffer where the data will be written.</param>
            <param name="offset">Starting position in the buffer where data will be wqritten.</param>
            <param name="count">Requested amount of data to be read.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the data to the stream.
            </summary>
            <param name="buffer">Buffer to be written to the stream</param>
            <param name="offset">Starting podition in the buffer from where data will be read.</param>
            <param name="count">Amount of data to be read from the buffer and written to the stream.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.WriteWithoutCopying(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes data to the stream the way that it just stores the reference to the input data.
            </summary>
            <remarks>
            It does not copy the incoming data to the stream but instead of that it just stores the reference.
            This approach is very fast but the input byte[] array should not be modified after calling this method.
            </remarks>
            <param name="data">data to be written to the stream.</param>
            <param name="offset">Starting position in the buffer from where data will be read.</param>
            <param name="count">Amount of data to be read from the buffer and written to the stream.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Close">
            <summary>
            Closes the stream and releases the reading thread waiting for data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.myMessageQueue">
            <summary>
            The writing puts the byte sequences to the queue as they come.
            The reading removes the sequences of bytes from the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.StreamUtil">
            <summary>
            Internal helper functionality for reading data from a stream.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.NamespaceDoc">
            <summary>
            Helper to write and read messages sfrom a stream.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.NamespaceGroupDoc">
            <summary>
            Serialization of messages and helpers for processing messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.EneterTrace">
            <summary>
            Super duper trace.
            </summary>
            <remarks>
            <example>
            Example showing how to enable tracing of communication errors and warnings to a file:
            <code>
            EneterTrace.DetailLevel = EneterTrace.EDetailLevel.Short;
            EneterTrace.TraceLog = new StreamWriter("d:/tracefile.txt");
            </code>
            </example>
            <example>
            Example showing how to enable tracing of detailed communication sequence to a file:
            <code>
            EneterTrace.DetailLevel = EneterTrace.EDetailLevel.Debug;
            EneterTrace.TraceLog = new StreamWriter("d:/tracefile.txt");
            </code>
            </example>
            <example>
            Example showing how you can trace entering/leaving methods:
            <code>
            private class MyClass
            {
                private void MyMethod()
                {
                    // Tracing entering and leaving the method.
                    // Note: The entering-leaving is traced only if detail level is 'Debug'.
                    using (EneterTrace.Entering())
                    {
                        ... method implementation ...
                        
                        // Tracing a warning message.
                        EneterTrace.Warning("This is a warning message.");
                        
                        ...
                    }
                }
            }
            
            The output:
            11:59:11.365 ~008 --> YourNameSpace.MyClass.MyMethod
            11:59:11.704 ~008  W: YourNameSpace.MyClass.MyMethod This is a warning message.
            11:59:12.371 ~008 &lt;--  YourNameSpace.MyClass.MyMethod [00:00:01 000ms 969.0us]
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel">
            <summary>
            Detail level of the trace.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.None">
            <summary>
            Messages are not traced.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.Short">
            <summary>
            Info, Warning and Error messages.<br/>
            The debug messages and entering-leaving messages are not traced.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.Debug">
            <summary>
            All messages are traced.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Entering(System.String)">
            <summary>
            Traces entering-leaving the method.
            </summary>
            <remarks>
            The enetering information for the method calling this constructor is put to the trace
            and the measuring of the time starts.
            In order to trace entering-leaving, the detail level must be set to 'Debug'.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.System#IDisposable#Dispose">
            <summary>
            Traces the leaving from the method including the duration time.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String)">
            <summary>
            Traces the info message.
            </summary>
            <param name="message">info message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String,System.Exception)">
            <summary>
            Traces the info message.
            </summary>
            <param name="message">info message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String)">
            <summary>
            Traces warning message.
            </summary>
            <param name="message">warning message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String,System.Exception)">
            <summary>
            Traces the warning message.
            </summary>
            <param name="message">warning message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String)">
            <summary>
            Traces the error message.
            </summary>
            <param name="message">error message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String,System.Exception)">
            <summary>
            Traces the error message.
            </summary>
            <param name="message">error message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Debug(System.String)">
            <summary>
            Traces the debug message.
            </summary>
            <remarks>
            To trace debug messages, the detail level must be set to debug.
            </remarks>
            <param name="message">error message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.StartProfiler">
            <summary>
            Starts the profiler measurement.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.StopProfiler">
            <summary>
            Stops the profiler measurement and writes results to the trace.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.TraceLog">
            <summary>
            Sets or gets the user defined trace.
            </summary>
            <remarks>
            If the value is set, the trace messages are written to the specified trace and to the debug port.
            If the value is null, then messages are written only to the debug port.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.DetailLevel">
            <summary>
            Sets or gets the detail level of the trace.
            </summary>
            <remarks>
            If the detail level is set to 'Short' then only info, warning and error messages are traced.<br/>
            If the detail level is set to 'Debug' then all messages are traced.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.NameSpaceFilter">
            <summary>
            Sets or gets the regular expression that will be applied to the namespace to filter traced messages.
            </summary>
            <remarks>
            Sets or gets the regular expression that will be applied to the name space of the traced message.
            If the namespace matches with the regular expression, the message will be traced.
            If the filter is set to null, then the filter is not used and all messages will be traced.
            <example>
            The following example shows how to set the filter to trace a certain namespace.
            <code>
            // Set the debug detailed level.
            EneterTrace.DetailLevel = EneterTrace.EDetailLevel.Debug;
            
            // Examples:
            // Traces all name spaces starting with 'My.NameSpace'.
            EneterTrace.NameSpaceFilter = new Regex(@"^My\.NameSpace");
            
            // Traces exactly the name space 'My.NameSpace'.
            EneterTrace.NameSpaceFilter = new Regex(@"^My\.NameSpace$");
            
            // Traces name spaces starting with 'Calc.Methods' or 'App.Utilities'.
            EneterTrace.NameSpaceFilter = new Regex(@"^Calc\.Methods|^App\.Utilities");
            
            // Traces all name spaces except namespaces starting with 'Eneter'.
            EneterTrace.NameSpaceFilter = new Regex(@"^(?!\bEneter\b)");
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.EnqueueJob(System.Action)">
            <summary>
            Enqueues a job to the queue.
            </summary>
            <remarks>
            The queueing of jobs ensures, the jobs are performed in the correct order
            and the writing of the processing does not consume the execution thread.
            </remarks>
            <param name="job"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.ProcessJobs(System.Object)">
            <summary>
            Removes traces from the queue and writes them.
            </summary>
            <remarks>
            The method is executed from a different thread.
            The thread then loops until the queue is processed.
            </remarks>
            <param name="x"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.#ctor">
            <summary>
            Private helper constructor.
            </summary>
            <remarks>
            The constructor is private, so the class can be enstantiating only via the 'Entering' method.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.ErrorHandler">
            <summary>
            Internal helper class to trace typical messags.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.NamespaceDoc">
            <summary>
            Tracing of communication.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.ERpcRequest">
            <summary>
            Internal commands for interaction via RPC.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Rpc.ERpcRequest.InvokeMethod">
            <summary>
            Client invokes a method.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Rpc.ERpcRequest.SubscribeEvent">
            <summary>
            Client subscribes an event.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Rpc.ERpcRequest.UnsubscribeEvent">
            <summary>
            Client unsubscribes an event.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Rpc.ERpcRequest.RaiseEvent">
            <summary>
            Service raises an event.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Rpc.ERpcRequest.Response">
            <summary>
            RPC service sends back a response for 'InvokeMethod', 'SubscribeEvent' or 'UnsubscribeEvent'.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1">
            <summary>
            Client which can use Remote Procedure Calls (note: it also works with Java and Android).
            </summary>
            <remarks>
            RpcClient acts as a proxy providing the communication functionality allowing a client to call methods exposed by the service.
            </remarks>
            <typeparam name="TServiceInterface">Interface exposed by the service.</typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.ConnectionOpened">
            <summary>
            Event raised when the connection with the service is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.ConnectionClosed">
            <summary>
            Event raised when the connection with the service is closed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.Proxy">
            <summary>
            Returns service proxy instance.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.SubscribeRemoteEvent``1(System.String,System.EventHandler{``0})">
            <summary>
            Subscribes to an event from the service.
            </summary>
            <typeparam name="TEventArgs">Type of the event args. It must be derived from EventArgs.</typeparam>
            <param name="eventName">name of the event</param>
            <param name="eventHandler">event handler processing the event</param>
            <remarks>
            You can use this method for subscribing if you do not want to use the service proxy.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.UnsubscribeRemoteEvent(System.String,System.Delegate)">
            <summary>
            Unsubscribes from the event in the service.
            </summary>
            <param name="eventName">name of the event</param>
            <param name="eventHandler">event handler that shall be unsubscribed</param>
            <remarks>
            You can use this method for unsubscribing if you do not want to use the service proxy.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.CallRemoteMethod(System.String,System.Object[])">
            <summary>
            Calls a method in the service.
            </summary>
            <param name="methodName">name of the method that shall be called.</param>
            <param name="args">list of arguments</param>
            <returns>returned value. null if it returns 'void'</returns>
            <remarks>
            You can use this method if you do not want to use the service proxy.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.IRpcFactory">
            <summary>
            Creates services and clients that can communicate using Remote Procedure Calls.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcFactory.CreateClient``1">
            <summary>
            Creates RPC client for the given interface.
            </summary>
            <typeparam name="TServiceInterface">service interface type.</typeparam>
            <returns>RpcClient instance</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcFactory.CreateSingleInstanceService``1(``0)">
            <summary>
            Creates single-instance RPC service for the given interface.
            </summary>
            <remarks>
            Single-instance means that there is one instance of the service shared by all clients.
            </remarks>
            <typeparam name="TServiceInterface">service interface type</typeparam>
            <param name="service">instance implementing the given service interface</param>
            <returns>RpcService instance.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcFactory.CreatePerClientInstanceService``1(System.Func{``0})">
            <summary>
            Creates per-client-instance RPC service for the given interface.
            </summary>
            <remarks>
            Per-client-instance means that for each connected client is created a separate instace of the service.
            </remarks>
            <typeparam name="TServiceInterface">service interface type</typeparam>
            <param name="serviceFactoryMethod">factory method used to create the service instance when the client is connected</param>
            
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.IRpcService`1">
            <summary>
            Service which exposes the interface for Remote Procedure Call (note: it also works with .NET).
            </summary>
            <typeparam name="TServiceInterface">Service interface.</typeparam>
            <remarks>
            RpcService acts as a stub which provides the communication functionality for an instance implementing the given service interface.<br/>
            The provided service type must be an interface fulfilling following criteria:
            <ul>
            <li>Interface is not generic.</li>
            <li>Methods are not overloaded. It means there are no two methods with the same name.</li>
            <li>It can use events.</li>
            </ul>
            
            <example>
            Declaring the service.
            <code>
            public interface IHello
            {
                // Events work too.
                event EventHandler&lt;MyEventArgs&gt; SomethingHappened;
            
                int Sum(int a, int b);
            
                void DoSomething();
            }
            </code>
            </example>
            
            <example>
            The following example shows how to declare interface that can be used for Java/C# communication.
            <code>
            // C# interface
            public interface IMyInterface
            {
               // Event without arguments.
               event EventHandler SomethingHappened;
               
               // Event with arguments.
               event EventHandler&lt;MyEventArgs&gt; SomethingElseHappened;
               
               // Simple method.
               void DoSomething();
               
               // Method with arguments.
               int Calculate(int a, int b);
            }
            </code>
            
            <code>
            // Java equivalent
            // Note: Names of methods and events must be same. So e.g. if the interface is declared in .NET with
            //       then you may need to start method names with Capital.
            public interface IMyInterface
            {
               // Event without arguments.
               Event&lt;EventArgs&gt; SomethingHappened();
               
               // Event with arguments.
               Event&lt;MyArgs&gt; SomethingElseHappened();
               
               // Simple method.
               void DoSomething();
               
               // Method with arguments.
               int Calculate(int a, int b);
            }
            </code>
            </example>
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcService`1.ResponseReceiverConnected">
            <summary>
            Event raised when a client connected the service.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcService`1.ResponseReceiverDisconnected">
            <summary>
            Event raised when a client got disconnected from the service.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.RpcCustomSerializer">
            <summary>
            Serializer optimized for RPC.
            </summary>
            <remarks>
            Performance of this serializer is optimized for RPC.
            To increase the performance it serializes RpcMessage (which is internaly used for RPC interaction) into a special byte sequence.
            It uses underlying serializer to serialize method inrput paramters.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcCustomSerializer.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="serializer">Underlying serializer used to serialize/deserialize method's input parameters.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcCustomSerializer.Serialize``1(``0)">
            <summary>
            Serializes data.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>data serialized into byte[]</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcCustomSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">data to be deserialized. The expected type is byte[].</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.RpcException">
            <summary>
            Exception thrown if an RPC call fails on the service side.
            </summary>
            <remarks>
            E.g. in case the service method throws an exception it is transfered to the client.
            When the client receives the exception from the service it creates RpcException and stores there all details
            about original service exception. The RpcException is then thrown and can be processed by the client.  
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcException.ServiceExceptionType">
            <summary>
            Gets name of the exception type thrown in the service.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcException.ServiceExceptionDetails">
            <summary>
            Gets service exception details including callstack.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.RpcFactory">
            <summary>
            Creates services and clients that can communicate using RPC (Remote Procedure Calls).
            </summary>
            <remarks>
            RPC is the communication scenario where an application (typically client) executes a method in another application (typically service). 
            RpcFactory provides methods to instantiate RpcService and RpcClient objects.
            
            RpcService acts as a stub which provides the communication functionality allowing the service to be reached from outside.
            RpcClient acts as a proxy which provides the communication functionality allowing the client to call remote methods in the service.
            
            The following example shows simple client-service communication using RPC.
            
            <example>
            Implementing the service:
            <code>
            public interface IHello
            {
                event EventHandler&lt;MyEventArgs&gt; SomethingHappned;
                int Calculate(int a, int b);
            }
            
            public class HelloService : IHello
            {
                public event EventHandler&lt;MyEventArgs&gt; SomethingHappned;
            
                int Calculate(int a, int b)
                {
                    return a + b;
                }
            
                public void RaiseEvent()
                {
                    if (SomethingHappned != null)
                    {
                        SomethingHappned(this, new MyEventArgs());
                    }
                }
            }
            
            
            class Program
            {
                static void Main(string[] args)
                {
                    // Instantiate service.
                    HelloService aHelloService = new HelloService();
                    IRpcFactory anRpcFactory = new RpcFactory();
                    IRpcService&lt;IHello&gt; aService = anRpcFactory.CreateService&lt;ICalculator&gt;(aHelloService);
            
                    // Attach input channel and start listening.
                    IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
                    IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:8045/");
                    aService.AttachDuplexInputChannel(anInputChannel);
            
                    Console.WriteLine("Hello service started. Press ENTER to stop.");
                    Console.ReadLine();
            
                    // Detach input channel and stop listening.
                    // Note: it releases the listening thread.
                    aService.DetachDuplexInputChannel();
                }
            }
            </code>
            </example>
            
            <example>
            Using service from the client.
            <code>
            // Get the service proxy for the interface.
            IRpcFactory anRpcFactory = new RpcFactory();
            myRpcClient = anRpcFactory.CreateClient&lt;IHello&gt;();
            
            // Attach output channel and be able to communicate.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8045/");
            myRpcClient.AttachDuplexOutputChannel(anOutputChannel);
            
            // Call service.
            IHello aServiceProxy = myRpcClient.Proxy;
            int aResult = aServiceProxy.Calculate(10, 20);
            </code>
            </example>
            
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcFactory.#ctor">
            <summary>
            Constructs RpcFactory with default <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs RpcFactory with specified serializer.
            </summary>
            <remarks>
            List of serializers provided by Eneter: <see cref="N:Eneter.Messaging.DataProcessing.Serializing"/>.
            </remarks>
            <param name="serializer"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcFactory.CreateClient``1">
            <summary>
            Creates RPC client for the given interface.
            </summary>
            <typeparam name="TServiceInterface">service interface type</typeparam>
            <returns>RpcClient instance</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcFactory.CreateSingleInstanceService``1(``0)">
            <summary>
            Creates single-instance RPC service for the given interface.
            </summary>
            <remarks>
            Single-instance means that there is one instance of the service which shared by all clients.
            </remarks>
            <typeparam name="TServiceInterface">service interface type</typeparam>
            <param name="service">instance implementing the given service interface</param>
            <returns>RpcService instance.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcFactory.CreatePerClientInstanceService``1(System.Func{``0})">
            <summary>
            Creates per-client-instance RPC service for the given interface.
            </summary>
            <remarks>
            Per-client-instance means that for each connected client is created a separate instace of the service.
            </remarks>
            <typeparam name="TServiceInterface">service interface type</typeparam>
            <param name="serviceFactoryMethod">factory method used to create the service instance when the client is connected</param>
            
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcFactory.Serializer">
            <summary>
            Gets/sets serializer used for serializing messages between RpcClient and RpcService.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcFactory.SerializerProvider">
            <summary>
            Gets/sets callback for retrieving serializer based on response receiver id.
            </summary>
            <remarks>
            This callback is used by RpcService when it needs to serialize/deserialize the communication with RpcClient.
            Providing this callback allows to use a different serializer for each connected client.
            This can be used e.g. if the communication with each client needs to be encrypted by a differently.<br/>
            <br/>
            The default value is null and it means SerializerProvider callback is not used and one serializer which specified in the Serializer property is used for all serialization/deserialization.<br/>
            If SerializerProvider is not null then the setting in the Serializer property is ignored.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcFactory.RpcClientThreading">
            <summary>
            Gets/sets threading mechanism used for invoking events (if RPC interface has some) and ConnectionOpened and ConnectionClosed events.
            </summary>
            <remarks>
            Default setting is that events are routed one by one via a working thread.<br/>
            It is recomended not to set the same threading mode for the attached output channel because a deadlock can occur when
            a remote procedure is called (e.g. if a return value from a remote method is routed to the same thread as is currently waiting for that return value the deadlock occurs).<br/>
            <br/>
            Note: The threading mode for the RPC service is defined by the threading mode of attached duplex input channel.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcFactory.RpcTimeout">
            <summary>
            Gets/sets timeout which specifies until when a call to a remote method must return.
            </summary>
            <remarks>
            Default value is TimeSpan.FromMilliseconds(-1) what is the infinite time. 
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.RpcMessage">
            <summary>
            Internal message used for the communication between RpcClient and RpcService.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.Id">
            <summary>
            Identifies the request on the client side.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.Request">
            <summary>
            Identifies the type of the request/response message.
            </summary>
            <remarks>
            e.g. if it is InvokeMethod, SubscribeEvent, UnsubscribeEvent, RaiseEvent or Response.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.OperationName">
            <summary>
            The name of the method or event which shall be performed.
            </summary>
            <remarks>
            e.g. in case of InvokeMethod it specifies which method shall be invoked.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.SerializedParams">
            <summary>
            Serialized input parameters.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.SerializedReturn">
            <summary>
            Serialized return value.
            </summary>
            <remarks>
            If it is method returning void then the return value is null.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.ErrorType">
            <summary>
            If an error occurred in the service.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.ErrorMessage">
            <summary>
            Exception message from the service.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.ErrorDetails">
            <summary>
            Exception details from the service.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.NamespaceDoc">
            <summary>
            Remote Procedure Calls (RPC).
            </summary>
            <example>
            For more details see example:
            <ul>
            <li>Simple calculator service - <see cref="T:Eneter.Messaging.EndPoints.Rpc.RpcFactory"/></li>
            </ul>
            </example>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory">
            <summary>
            Implements the factory to create duplex string message sender and receiver.
            </summary>
            <remarks>
            <example>
            Client sending and receiving text messages.
            <code>
            // Create string message sender.
            IDuplexStringMessagesFactory aSenderFactory = new DuplexStringMessagesFactory();
            IDuplexStringMessageSender aSender = aSenderFactory.CreateDuplexStringMessageSender();
            
            // Subscribe to receive responses.
            aSender.ResponseReceived += OnResponseReceived;
            
            // Attach duplex output channel and be able to send messages and receive responses.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:9876/");
            aSender.AttachDuplexOutputChannel(anOutputChannel);
            
            // Send a message.
            aSender.SendMessage("Hello.");
            
            ...
            
            // Do not forget to detach the output channel e.g. before application stops.
            // It will release the thread listening to response messages.
            aSender.DetachDuplexOutputChannnel();
            
            </code>
            </example>
            <example>
            Service sending and receiving text messages.
            <code>
            // Create string message receiver.
            IDuplexStringMessagesFactory aReceiverFactory = new DuplexStringMessagesFactory();
            IDuplexStringMessageReceiver aReceiver = aReceiverFactory.CreateDuplexStringMessageReciever();
            
            // Subscribe to receive responses.
            aReceiver.RequestReceived += OnRequestReceived;
            
            // Attach duplex input channel and start listening.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:9876/");
            aReceiver.AttachDuplexInputChannel(anInputChannel);
            
            ...
            
            // Stop listening.
            aReceiver.DetachDuplexInputChannel();
            
            ...
            
            void OnRequestReceived(object sender, StringRequestReceivedEventArgs e)
            {
                IDuplexStringMessageReceiver aReceiver = (IDuplexStringMessageReceiver) sender;
                
                // Send back the response message.
                aReceiver.SendResponseMessage(e.ResponseReceiverId, "Hi, I am here.");
            }
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates the duplex string message sender.
            </summary>
            <returns>duplex string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates the duplex string message receiver.
            </summary>
            <returns>duplex string message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver">
            <summary>
            Receiver of text messages.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.RequestReceived">
            <summary>
            The event is raised when a text message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverConnected">
            <summary>
            The event is raised when a duplex string message sender opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverDisconnected">
            <summary>
            The event is raised when a duplex string message sender closed the connection.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.SendResponseMessage(System.String,System.String)">
            <summary>
            Sends the response message back to the string message sender.
            </summary>
            <param name="responseReceiverId">identifies the string message sender that shall receive the response</param>
            <param name="responseMessage">response text message</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender">
            <summary>
            Sender of text messages.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ConnectionOpened">
            <summary>
            The event is raised when a response message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ConnectionClosed">
            <summary>
            The event is raised when the connection with the receiver is closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ResponseReceived">
            <summary>
            The event is raised when a response message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.SendMessage(System.String)">
            <summary>
            Sends the text message to the response receiver.
            </summary>
            <param name="message">message</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory">
            <summary>
            Creates sender and receiver for text messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates message sender.
            </summary>
            <returns>string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates message receiver.
            </summary>
            <returns>string message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs">
            <summary>
            Event type for text request message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the event from thr parameters.
            </summary>
            <param name="requestMessage"></param>
            <param name="responseReceiverId"></param>
            <param name="senderAddress"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.RequestMessage">
            <summary>
            Returns the request message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.ResponseReceiverId">
            <summary>
            Returns the response receiver id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs">
            <summary>
            Event type for text response message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.ResponseMessage">
            <summary>
            Returns the response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.NamespaceDoc">
            <summary>
            Sending and receiving text messages.
            </summary>
            <example>
            For more details see example:
            <ul>
                <li><see cref="T:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory"/> - sending and receiving text messages.</li>
            </ul>
            </example>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory">
            <summary>
            Factory to create typed message senders and receivers.
            </summary>
            <remarks>
            The following example shows how to send a receive messages:
            <example>
            Implementation of receiver:
            <code>
            using System;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorService
            {
                // Request message.
                public class RequestMessage
                {
                    public int Number1 { get; set; }
                    public int Number2 { get; set; }
                }
            
                // Response message.
                public class ResponseMessage
                {
                    public int Result { get; set; }
                }
            
                class Program
                {
                    static void Main(string[] args)
                    {
                        // Create message receiver.
                        IDuplexTypedMessagesFactory aReceiverFactory = new DuplexTypedMessagesFactory();
                        IDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt; aReceiver =
                            aReceiverFactory.CreateDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Subscribe to process request messages.
                        aReceiver.MessageReceived += OnMessageReceived;
            
                        // Use WebSocket for the communication.
                        // Note: You can also other messagings. E.g. TcpMessagingSystemFactory
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the input channel to the receiver and start listening.
                        aReceiver.AttachDuplexInputChannel(anInputChannel);
            
                        Console.WriteLine("The calculator service is running. Press ENTER to stop.");
                        Console.ReadLine();
            
                        // Detach the input channel to stop listening.
                        aReceiver.DetachDuplexInputChannel();
                    }
            
                    private static void OnMessageReceived(object sender, TypedRequestReceivedEventArgs&lt;RequestMessage&gt; e)
                    {
                        // Calculate numbers.
                        ResponseMessage aResponseMessage = new ResponseMessage();
                        aResponseMessage.Result = e.RequestMessage.Number1 + e.RequestMessage.Number2;
            
                        Console.WriteLine("{0} + {1} = {2}", e.RequestMessage.Number1, e.RequestMessage.Number2, aResponseMessage.Result);
            
                        // Send back the response message.
                        var aReceiver = (IDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt;)sender;
                        aReceiver.SendResponseMessage(e.ResponseReceiverId, aResponseMessage);
                    }
                }
            }
            
            </code>
            </example>
            <example>
            Implementation of sender:
            <code>
            using System;
            using System.Windows.Forms;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorClient
            {
                public partial class Form1 : Form
                {
                    // Request message.
                    public class RequestMessage
                    {
                        public int Number1 { get; set; }
                        public int Number2 { get; set; }
                    }
            
                    // Response message.
                    public class ResponseMessage
                    {
                        public int Result { get; set; }
                    }
            
                    private IDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt; mySender;
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        OpenConnection();
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        CloseConnection();
                    }
            
            
                    private void OpenConnection()
                    {
                        // Create the message sender.
                        IDuplexTypedMessagesFactory aSenderFactory = new DuplexTypedMessagesFactory();
                        mySender = aSenderFactory.CreateDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Subscribe to receive response messages.
                        mySender.ResponseReceived += OnResponseReceived;
            
                        // Use Websocket for the communication.
                        // If you want to use TCP then use TcpMessagingSystemFactory().
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the output channel and be able to send messages
                        // and receive response messages.
                        mySender.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void CloseConnection()
                    {
                        // Detach input channel and stop listening to response messages.
                        mySender.DetachDuplexOutputChannel();
                    }
            
                    private void CalculateBtn_Click(object sender, EventArgs e)
                    {
                        // Create the request message.
                        RequestMessage aRequest = new RequestMessage();
                        aRequest.Number1 = int.Parse(Number1TextBox.Text);
                        aRequest.Number2 = int.Parse(Number2TextBox.Text);
            
                        // Send request to the service to calculate 2 numbers.
                        mySender.SendRequestMessage(aRequest);
                    }
            
                    private void OnResponseReceived(object sender, TypedResponseReceivedEventArgs&lt;ResponseMessage&gt; e)
                    {
                        // Display the result using the UI thread.
                        UI(() =&gt; ResultTextBox.Text = e.ResponseMessage.Result.ToString());
                    }
            
                    // Helper method to invoke a delegate in the UI thread.
                    // Note: You can manipulate UI controls only from the UI tread.
                    private void UI(Action action)
                    {
                        if (InvokeRequired)
                        {
                            Invoke(action);
                        }
                        else
                        {
                            action();
                        }
                    }
                }
            }
            </code>
            </example>
            <example>
            Implementation of synchronous sender (after sending it waits for the response):
            <code>
            using System;
            using System.Windows.Forms;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorClientSync
            {
                public partial class Form1 : Form
                {
                    // Request message.
                    public class RequestMessage
                    {
                        public int Number1 { get; set; }
                        public int Number2 { get; set; }
                    }
            
                    // Response message.
                    public class ResponseMessage
                    {
                        public int Result { get; set; }
                    }
            
                    private ISyncDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt; mySender;
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        OpenConnection();
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        CloseConnection();
                    }
            
                    private void OpenConnection()
                    {
                        // Create the message sender.
                        IDuplexTypedMessagesFactory aSenderFactory = new DuplexTypedMessagesFactory();
                        mySender = aSenderFactory.CreateSyncDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Use Websocket for the communication.
                        // If you want to use TCP then use TcpMessagingSystemFactory().
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the output channel and be able to send messages
                        // and receive response messages.
                        mySender.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void CloseConnection()
                    {
                        // Detach input channel and stop listening to response messages.
                        mySender.DetachDuplexOutputChannel();
                    }
            
                    private void CalculateBtn_Click(object sender, EventArgs e)
                    {
                        // Create the request message.
                        RequestMessage aRequest = new RequestMessage();
                        aRequest.Number1 = int.Parse(Number1TextBox.Text);
                        aRequest.Number2 = int.Parse(Number2TextBox.Text);
            
                        // Send request to the service to calculate 2 numbers.
                        ResponseMessage aResponse = mySender.SendRequestMessage(aRequest);
            
                        // Display the result.
                        ResultTextBox.Text = aResponse.Result.ToString();
                    }
                }
            }
            </code>
            </example>
            
            
            
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with xml serializer. <br/>
            </summary>
            <remarks>
            The factory will create senders and receivers with the default XmlStringSerializer<br/>
            and the factory will create ISyncDuplexTypedMessageSender that can wait infinite
            time for the response message from the service.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified serializer.
            </summary>
            <remarks>
            The factory will create senders and receivers with the specified serializer
            and the factory will create ISyncDuplexTypedMessageSender that can wait infinite
            time for the response message from the service.<br/>
            <br/>
            For possible serializers you can refer to <see cref="N:Eneter.Messaging.DataProcessing.Serializing"/>
            </remarks>
            <param name="serializer">Serializer used to serialize request and response messages.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(System.TimeSpan)">
            <summary>
            Constructs the factory with specified timeout for ISyncDuplexTypedMessageSender.
            </summary>
            <remarks>
            The factory will create senders and receivers using the default XmlStringSerializer
            and the factory will create ISyncDuplexTypedMessageSender with specified timeout
            indicating how long it can wait for a response message from the service.
            The timeout value TimeSpan.FromMilliseconds(-1) means infinite time.
            </remarks>
            <param name="syncResponseReceiveTimeout">maximum waiting time when synchronous message sender is used.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(System.TimeSpan,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified timeout for synchronous message sender and specified serializer.
            </summary>
            <param name="syncResponseReceiveTimeout">maximum waiting time when synchronous message sender is used.</param>
            <param name="serializer">serializer that will be used to serialize/deserialize messages.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates duplex typed message sender that can send request messages and receive response
            messages of specified type.
            </summary>
            <typeparam name="TResponse">Type of response messages.</typeparam>
            <typeparam name="TRequest">Type of request messages.</typeparam>
            <returns>duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateSyncDuplexTypedMessageSender``2">
            <summary>
            Creates synchronous duplex typed message sender that sends a request message and then
            waits until the response message is received.
            </summary>
            <typeparam name="TResponse">Response message type.</typeparam>
            <typeparam name="TRequest">Request message type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates duplex typed message receiver that can receive request messages and
            send back response messages of specified type.
            </summary>
            <typeparam name="TResponse">Type of response messages.</typeparam>
            <typeparam name="TRequest">Type of receiving messages.</typeparam>
            <returns>duplex typed message receiver</returns>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.SyncDuplexTypedSenderThreadMode">
            <summary>
            Gets or sets the threading mode for receiving ConnectionOpened and ConnectionClosed events for SyncDuplexTypedMessageSender.
            </summary>
            <remarks>
            E.g. you use SyncDuplexTypedMessageSender and you want to route ConnectionOpened and ConnectionClosed events
            to the main UI thread of your WPF based application. Therefore you specify WindowsDispatching when you create your
            TCP duplex output channel which you then attach to the SyncDuplexTypedMessageSender.<br/>
            Later when the application is running you call SyncDuplexTypedMessageSender.SendRequestMessage(..).<br/>
            However if you call it from the main UI thread the deadlock occurs.
            Because this component is synchronous the SendRequestMessage(..) will stop the calling main UI thread and will wait
            for the response. But the problem is when the response comes the underlying TCP messaging will try to route it to
            the main UI thread (as was specified during creating TCP duplex output channel).<br/>
            But because the main UI thread is suspending and waiting the message will never arrive.<br/>
            <br/>
            Solution:<br/>
            Do not specify the threading mode when you create yur duplex output channel but specify it using the
            SyncDuplexTypedSenderThreadMode property when you create SyncDuplexTypedMessageSender.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.Serializer">
            <summary>
            Serializer for messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.SerializerProvider">
            <summary>
            Gets/sets callback for retrieving serializer based on response receiver id.
            </summary>
            <remarks>
            This callback is used by DuplexTypedMessageReceiver when it needs to serialize/deserialize the communication with DuplexTypedMessageSender.
            Providing this callback allows to use a different serializer for each connected client.
            This can be used e.g. if the communication with each client needs to be encrypted using a different password.<br/>
            <br/>
            The default value is null and it means SerializerProvider callback is not used and one serializer which specified in the Serializer property is used for all serialization/deserialization.<br/>
            If SerializerProvider is not null then the setting in the Serializer property is ignored.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.SyncResponseReceiveTimeout">
            <summary>
            Timeout which is used for SyncDuplexTypedMessageSender.
            </summary>
            <remarks>
            When SyncDuplexTypedMessageSender calls SendRequestMessage(..) then it waits until the response is received.
            This timeout specifies the maximum wating time. The default value is -1 and it means infinite time.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2">
            <summary>
            Receiver of one specified message type.
            </summary>
            <remarks>
            This is a service component which can receive request messages and send back response messages.
            DuplexTypedMessageReceiver can receive messages only from DuplexTypedMessageSender or from SyncDuplexTypedMessageSender.
            </remarks>
            <typeparam name="TResponse">Type of response message which can be sent by the receiver.</typeparam>
            <typeparam name="TRequest">Type of request message which can be received by the receiver.</typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.MessageReceived">
            <summary>
            Raised when the request message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            Raised when the connection was successfully opened
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            Raised when a duplex typed message sender (client) closed the connection.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.SendResponseMessage(System.String,`0)">
            <summary>
            Sends the response message.
            </summary>
            <remarks>
            The message will be serialized and sent via duplex output channel to the response receiver (DuplexTypedMessageSender or SyncDuplexTypedMessageSender).
            DuplexTypedMessageSender deserializes the message and raises the event ResponseReceived.
            In case of SyncDuplexTypedMessageSender it returns from the method SendRequestMessage.
            </remarks>
            <param name="responseReceiverId">Identifies response receiver which will receive the message.
            If responseReceiverId is * the broadcast to all connected response receivers will be sent.</param>
            <param name="responseMessage">response message</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2">
            <summary>
            Sender of one specified message type.
            </summary>
            <remarks>
            This is a client component which can send request messages and receive response messages.
            DuplexTypedMessageSender can send messages only to DuplexTypedMessageReceiver.
            </remarks>
            <typeparam name="TResponse">receives response messages of this type.</typeparam>
            <typeparam name="TRequest">sends messages of this type.</typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ConnectionOpened">
            <summary>
            The event is raised when the connection with the receiver is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ConnectionClosed">
            <summary>
            The event is raised when the connection with the receiver is closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ResponseReceived">
            <summary>
            The event is raised when a response message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends message.
            </summary>
            <remarks>
            The given message is serialized and then sent via duplex output channel to the connected DuplexTypedMessageReceiver.
            DuplexTypedMessageReceiver deserilizes the message and raises the MessageReceived event to notify that a message is received.
            </remarks>
            <param name="message">request message</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory">
            <summary>
            Creates typed message senders and receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates message sender (client) which can send messages and receive response messages.
            </summary>
            <typeparam name="TResponse">Type of response messages.</typeparam>
            <typeparam name="TRequest">Type of request messages.</typeparam>
            <returns>message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateSyncDuplexTypedMessageSender``2">
            <summary>
            Creates message sender (client) which sends a request message and then waits for the response.
            </summary>
            <typeparam name="TResponse">Type of response messages.</typeparam>
            <typeparam name="TRequest">Type of request messages.</typeparam>
            <returns>synchronous message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates message receiver (service) which can receive messages and send back response messages.
            </summary>
            <typeparam name="TResponse">Type of response messages.</typeparam>
            <typeparam name="TRequest">Type of request messages.</typeparam>
            <returns>typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageReceiver">
            <summary>
            Receiver for multiple message types.
            </summary>
            <remarks>
            It is a service component which can receive and send messages of multiple types.<br/>
            The following example shows how to create a service which can receive messages of various types:
            <example>
            <code>
            // Create multityped receiver
            IMultiTypedMessagesFactory aFactory = new MultiTypedMessagesFactory();
            IMultiTypedMessageReceiver aReceiver = aFactory.CreateMultiTypedMessageReceiver();
            
            // Register handlers for message types which can be received.
            aReceiver.RegisterRequestMessageReceiver&lt;Alarm&gt;(OnAlarmMessage);
            aReceiver.RegisterRequestMessageReceiver&lt;Image&gt;(OnImageMessage);
            
            // Attach input channel and start listening. E.g. using TCP.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:9043/");
            aReceiver.AttachDuplexInputChannel(anInputChannel);
            
            Console.WriteLine("Service is running. Press ENTER to stop.");
            Console.ReadLine();
            
            // Detach input channel and stop listening.
            aReceiver.DetachInputChannel();
            
            
            private void OnAlarmMessage(object sender, TypedRequestReceivedEventArgs&lt;Alarm&gt; e)
            {
               // Get alarm message data.
               Alarm anAlarm = e.RequestMessage;
            
               ...
            
               // Send response message.
               aReceiver.SendResponseMessage&lt;ResponseMessage&gt;(e.getResponseReceiverId(), aResponseMessage);
            }
            
            private void onImageMessage(object sender, TypedRequestReceivedEventArgs&lt;Image&gt; e)
            {
               // Get image message data.
               Image anImage = e.RequestMessage;
            
               ...
            
               // Send response message.
               aReceiver.SendResponseMessage&lt;ResponseMessage&gt;(e.getResponseReceiverId(), aResponseMessage);
            }
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageReceiver.ResponseReceiverConnected">
            <summary>
            Raised when a new client is connected.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageReceiver.ResponseReceiverDisconnected">
            <summary>
            Raised when a client closed the connection.
            </summary>
            <remarks>
            The event is raised only if the connection was closed by the client.
            It is not raised if the client was disconnected by IDuplexInputChannel.DisconnectResponseReceiver(...). 
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageReceiver.RegisterRequestMessageReceiver``1(System.EventHandler{Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs{``0}})">
            <summary>
            Registers message handler for specified message type.
            </summary>
            <remarks>
            If the specified message type is received the handler will be called to process it.
            </remarks>
            <typeparam name="T">Type of the message the handler shall process.</typeparam>
            <param name="handler">The callback method which will be called to process the message of the given type.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageReceiver.UnregisterRequestMessageReceiver``1">
            <summary>
            Unregisters the message handler for the specified message type.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageReceiver.RegisteredRequestMessageTypes">
            <summary>
            Returns the list of registered message types which can be received. 
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageReceiver.SendResponseMessage``1(System.String,``0)">
            <summary>
            Sends the response message.
            </summary>
            <remarks>
            The message of the specified type will be serialized and sent back to the response receiver.
            If the response receiver has registered a handler for this message type then the handler will be called to process the message.
            </remarks>
            <typeparam name="TResponseMessage">Type of the message.</typeparam>
            <param name="responseReceiverId">Identifies response receiver which will receive the message.
            If responseReceiverId is * then the broadcast message
            to all connected clients is sent.
            <example>
            <code>
            // Send broadcast to all connected clients.
            aReceiver.SendResponseMessage&lt;YourBroadcast&gt;("*", aBroadcastMessage);
            </code>
            </example>
            </param>
            <param name="responseMessage">response message</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageSender">
            <summary>
            Sender for multiple message types.
            </summary>
            <remarks>
            This is a client component which can send and receive messages of multiple types.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageSender.ConnectionOpened">
            <summary>
            Raised when the connection with the receiver is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageSender.ConnectionClosed">
            <summary>
            Raised when the service closed the connection with the client.
            </summary>
            <remarks>
            The event is raised only if the service closes the connection with the client.
            It is not raised if the client closed the connection by IDuplexOutputChannel.CloseConnection().
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageSender.RegisterResponseMessageReceiver``1(System.EventHandler{Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs{``0}})">
            <summary>
            Registers response message handler for specified message type.
            </summary>
            <remarks>
            If the response message of the specified type is received the handler will be called to process it.
            </remarks>
            <typeparam name="T">data type of the response message which will be handled by the handler</typeparam>
            <param name="handler">handler which will be called if the response message of specified type is received</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageSender.UnregisterResponseMessageReceiver``1">
            <summary>
            Unregisters the response message handler for the specified message type.
            </summary>
            <typeparam name="T">data type of the resposne message for which the handler shall be unregistered</typeparam>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageSender.RegisteredResponseMessageTypes">
            <summary>
            Returns the list of registered response message types which can be received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessageSender.SendRequestMessage``1(``0)">
            <summary>
            Sends request message.
            </summary>
            <remarks>
            The message of the specified type will be serialized and sent to the receiver.
            If the receiver has registered a handler for this message type then the handler will be called to process the message.
            </remarks>
            <typeparam name="TRequestMessage">Type of the message.</typeparam>
            <param name="message">request message</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessagesFactory">
            <summary>
            Creates multi-typed message senders and receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessagesFactory.CreateMultiTypedMessageSender">
            <summary>
            Creates multityped message sender which can send request messages and receive response messages.
            </summary>
            <returns>multi typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessagesFactory.CreateSyncMultiTypedMessageSender">
            <summary>
            Creates mulityped message sender which sends a request message and then waits for the response.
            </summary>
            <returns>synchronous multi typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IMultiTypedMessagesFactory.CreateMultiTypedMessageReceiver">
            <summary>
            Creates multityped message receiver which can receive request messages and send response messages.
            </summary>
            <returns>multi typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2">
            <summary>
            Synchronized sender for one specified message type (it waits until the response is received).
            </summary>
            <remarks>
            Message sender which sends request messages of specified type and receive response messages of specified type.
            Synchronous means when the message is sent it waits until the response message is received.
            If the waiting for the response message exceeds the specified timeout the TimeoutException is thrown.
            </remarks>
            <typeparam name="TResponse">Type of response message.</typeparam>
            <typeparam name="TRequest">Type of request message.</typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2.ConnectionOpened">
            <summary>
            Raised when the connection with the receiver is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2.ConnectionClosed">
            <summary>
            Raised when the service closed the connection with the client.
            </summary>
            <remarks>
            The event is raised only if the service closes the connection with the client.
            It is not raised if the client closed the connection by IDuplexOutputChannel.CloseConnection().
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends the request message and returns the response.
            </summary>
            <remarks>
            It waits until the response message is received. If waiting for the response exceeds the specified timeout
            TimeoutException is thrown.
            </remarks>
            <param name="message">request message</param>
            <returns>response message</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ISyncMultitypedMessageSender">
            <summary>
            Synchronized sender for multiple message types (it waits until the response is received).
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.ISyncMultitypedMessageSender.ConnectionOpened">
            <summary>
            Raised when the connection with the receiver is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.ISyncMultitypedMessageSender.ConnectionClosed">
            <summary>
            Raised when the service closed the connection with the client.
            </summary>
            <remarks>
            The event is raised only if the service closes the connection with the client.
            It is not raised if the client closed the connection by IDuplexOutputChannel.CloseConnection().
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ISyncMultitypedMessageSender.SendRequestMessage``2(``1)">
            <summary>
            Sends request message and returns the response.
            </summary>
            <typeparam name="TResponse">Type of request message.</typeparam>
            <typeparam name="TRequest">Type of response message.</typeparam>
            <param name="message">request message</param>
            <returns>response message</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessage">
            <summary>
            Internal message used for the communication between multi-typed message sender and receiver.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessage.TypeName">
            <summary>
            Name of the message type (without namespace).
            </summary>
            <remarks>
            In order to ensure better portability between .NET and Java the type name does not include the whole namespace
            but only the name.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessage.MessageData">
            <summary>
            Serialized message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessagesFactory">
            <summary>
            Factory to create multi-typed message senders and receivers.
            </summary>
            <remarks>
            The following example shows how to send and receive messages:
            <example>
            <code>
            public class MyRequestMessage
            {
                public double Number1 { get; set; }
                public double Number2 { get; set; }
            }
            
            class Program
            {
                static void Main(string[] args)
                {
                    try
                    {
                        // Create multi-typed receiver.
                        IMultiTypedMessagesFactory aFactory = new MultiTypedMessagesFactory();
                        IMultiTypedMessageReceiver aReceiver = aFactory.CreateMultiTypedMessageReceiver();
                    
                        // Register message types which can be processed.
                        aReceiver.RegisterRequestMessageReceiver&lt;int&gt;(OnIntMessage);
                        aReceiver.RegisterRequestMessageReceiver&lt;MyRequestMessage&gt;(OnMyReqestMessage);
                    
                        // Attach input channel and start listening.
                        IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
                        IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:8033/");
                        aReceiver.AttachDuplexInputChannel(anInputChannel);
                    
                        Console.WriteLine("Service is running. Press ENTER to stop.");
                        Console.ReadLine();
                    
                        // Detach input channel to stop the listening thread.
                        aReceiver.DetachDuplexInputChannel();
                    }
                    catch (Exception err)
                    {
                        EneterTrace.Error("Service failed.", err);
                    }
                }
            
                private static void OnIntMessage(Object eventSender, TypedRequestReceivedEventArgs&lt;int&gt; e)
                {
                    int aNumber = e.RequestMessage;
                    
                    // Calculate factorial.
                    int aResult = 1;
                    for (int i = 1; i &lt;= aNumber; ++i)
                    {
                        aResult *= i;
                    }
            
                    Console.WriteLine(aNumber + "! =" + aResult);
                
                    // Send back the result.
                    IMultiTypedMessageReceiver aReceiver = (IMultiTypedMessageReceiver)eventSender;
                    try
                    {
                        aReceiver.SendResponseMessage&lt;int&gt;(e.ResponseReceiverId, aResult);
                    }
                    catch (Exception err)
                    {
                        EneterTrace.Error("Failed to send the response message.", err);
                    }
                }
            
                private static void OnMyReqestMessage(Object eventSender, TypedRequestReceivedEventArgs&lt;MyRequestMessage&gt; e)
                {
                    MyRequestMessage aRequestMessage = e.RequestMessage;
                
                    double aResult = aRequestMessage.Number1 + aRequestMessage.Number2;
                
                    Console.WriteLine(aRequestMessage.Number1 + " + " + aRequestMessage.Number2 + " = " + aResult);
                
                    // Send back the message.
                    IMultiTypedMessageReceiver aReceiver = (IMultiTypedMessageReceiver)eventSender;
                    try
                    {
                        aReceiver.SendResponseMessage&lt;double&gt;(e.ResponseReceiverId, aResult);
                    }
                    catch (Exception err)
                    {
                        EneterTrace.Error("Failed to send the response message.", err);
                    }
                }
            }
            </code>
            </example>
            
            Implementation of sender (client):
            <example>
            <code>
            public partial class Form1 : Form
            {
                public class MyRequestMessage
                {
                    public double Number1 { get; set; }
                    public double Number2 { get; set; }
                }
            
                public class ggg
                {
                    public int a;
                }
            
                private IMultiTypedMessageSender mySender;
            
                public Form1()
                {
                    InitializeComponent();
            
                    OpenConnection();
                }
            
                private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                {
                    CloseConnection();
                }
            
                private void OpenConnection()
                {
                    IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory()
                    {
                        // Receive response messages in the main UI thread.
                        // Note: UI controls can be accessed only from the UI thread.
                        //       So if this is not set then your message handling method would have to
                        //       route it manually.
                        OutputChannelThreading = new WinFormsDispatching(this)
                    };
            
                    IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8033/");
            
                    IMultiTypedMessagesFactory aFactory = new MultiTypedMessagesFactory();
                    mySender = aFactory.CreateMultiTypedMessageSender();
            
                    // Register handlers for particular types of response messages.
                    mySender.RegisterResponseMessageReceiver&lt;int&gt;(OnIntMessage);
                    mySender.RegisterResponseMessageReceiver&lt;double&gt;(OnDoubleMessage);
            
                    // Attach output channel and be able to send messages and receive responses.
                    mySender.AttachDuplexOutputChannel(anOutputChannel);
                }
            
                private void CloseConnection()
                {
                    // Detach output channel and release the thread listening to responses.
                    mySender.DetachDuplexOutputChannel();
                }
            
                private void CalculateBtn_Click(object sender, EventArgs e)
                {
                    // Create message.
                    MyRequestMessage aRequest = new MyRequestMessage();
                    aRequest.Number1 = double.Parse(Number1TextBox.Text);
                    aRequest.Number2 = double.Parse(Number2TextBox.Text);
            
                    // Send message.
                    mySender.SendRequestMessage&lt;MyRequestMessage&gt;(aRequest);
                }
            
                private void CalculateFactorialBtn_Click(object sender, EventArgs e)
                {
                    // Create message.
                    int aNumber = int.Parse(FactorialNumberTextBox.Text);
            
                    // Send Message.
                    mySender.SendRequestMessage&lt;int&gt;(aNumber);
                }
            
                private void OnIntMessage(object sender, TypedResponseReceivedEventArgs&lt;int&gt; e)
                {
                    FactorialResultTextBox.Text = e.ResponseMessage.ToString();
                }
            
                private void OnDoubleMessage(object sender, TypedResponseReceivedEventArgs&lt;double&gt; e)
                {
                    ResultTextBox.Text = e.ResponseMessage.ToString();
                }
            }
            </code>
            </example>
            
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            It instantiates the factory which will create multi typed senders and receivers which will use
            default XmlStringSerializer and with infinite timeout for SyncMultiTypedMessageSender.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory.
            </summary>
            <remarks>
            It instantiates the factory with infinite timeout for SyncMultiTypedMessageSender.
            </remarks>
            <param name="serializer">serializer which will be used to serializer/deserialize messages</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessagesFactory.CreateMultiTypedMessageSender">
            <summary>
            Creates multi typed message sender.
            </summary>
            <remarks>
            The sender is able to send messages of various types and receive response messages of various types.
            </remarks>
            <returns>multi typed sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessagesFactory.CreateSyncMultiTypedMessageSender">
            <summary>
            Creates multi typed message sender which waits for the response message.
            </summary>
            <returns>synchronous multi typed sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessagesFactory.CreateMultiTypedMessageReceiver">
            <summary>
            Creates multi typed message receiver.
            </summary>
            <remarks>
            The receiver is able to receive messages of various types and send response messages
            of various types.
            </remarks>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessagesFactory.SyncDuplexTypedSenderThreadMode">
            <summary>
            Gets or sets the threading mode for receiving ConnectionOpened and ConnectionClosed events for SyncDuplexTypedMessageSender.
            </summary>
            <remarks>
            E.g. you use SyncDuplexTypedMessageSender and you want to route ConnectionOpened and ConnectionClosed events
            to the main UI thread of your WPF based application. Therefore you specify WindowsDispatching when you create your
            TCP duplex output channel which you then attach to the SyncDuplexTypedMessageSender.<br/>
            Later when the application is running you call SyncDuplexTypedMessageSender.SendRequestMessage(..).<br/>
            However if you call it from the main UI thread the deadlock occurs.
            Because this component is synchronous the SendRequestMessage(..) will stop the calling main UI thread and will wait
            for the response. But the problem is when the response comes the underlying TCP messaging will try to route it to
            the main UI thread (as was specified during creating TCP duplex output channel).<br/>
            But because the main UI thread is suspending and waiting the message will never arrive.<br/>
            <br/>
            Solution:<br/>
            Do not specify the threading mode when you create yur duplex output channel but specify it using the
            SyncDuplexTypedSenderThreadMode property when you create SyncDuplexTypedMessageSender.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessagesFactory.Serializer">
            <summary>
            Serializer for messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessagesFactory.SerializerProvider">
            <summary>
            Gets/sets callback for retrieving serializer based on response receiver id.
            </summary>
            <remarks>
            This callback is used by MultiTypedMessageReceiver when it needs to serialize/deserialize the communication with MultiTypedMessageSender.
            Providing this callback allows to use a different serializer for each connected client.
            This can be used e.g. if the communication with each client needs to be encrypted using a different password.<br/>
            <br/>
            The default value is null and it means SerializerProvider callback is not used and one serializer which specified in the Serializer property is used for all serialization/deserialization.<br/>
            If SerializerProvider is not null then the setting in the Serializer property is ignored.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessagesFactory.SyncResponseReceiveTimeout">
            <summary>
            Timeout which is used for SyncMultitypedMessageSender.
            </summary>
            <remarks>
            When SyncMultitypedMessageSender calls SendRequestMessage(..) then it waits until the response is received.
            This timeout specifies the maximum wating time. The default value is -1 and it means infinite time.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1">
            <summary>
            Event argument used when the typed message is received.
            </summary>
            <typeparam name="_RequestMessageType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,System.String,`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="senderAddress">address of the message sender. It is null if not applicable for the messaging system.</param>
            <param name="requestMessage">message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Constructs the message from the exception.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="senderAddress">address of the message sender. It is null if not applicable for the messaging system.</param>
            <param name="error">error detected during receiving the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.RequestMessage">
            <summary>
            Returns the received message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ResponseReceiverId">
            <summary>
            Returns the client identifier where the response can be sent.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1">
            <summary>
            Event argument used when a typed response message is received.
            </summary>
            <typeparam name="_ResponseMessageType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">response message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception detected during receiving the response message.
            </summary>
            <param name="error"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ResponseMessage">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns an exception detected during receiving the response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.VoidMessage">
            <summary>
            Represents an empty data type 'void'.
            Can be used if no type is expected as a message.
            </summary>
            <remarks>
            <example>
            The following example shows how to use VoidMessage to declare a message sender
            sending string messages and receiving "nothing".
            <code>
            ...
            IDuplexTypedMessageSender&lt;VoidMessage, string&gt; myMessageSender;
            ...
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.NamespaceDoc">
            <summary>
            Sending and receiving messages as typed data.
            </summary>
            E.g. you may want that the request message is type of YourRequest and the response message
            is type of YourResponse.
            <example>
            For more details see examples:
            <ul>
                <li><see cref="T:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory"/> - sending and receiving messages of declared type.</li>
                <li><see cref="T:Eneter.Messaging.EndPoints.TypedMessages.MultiTypedMessagesFactory"/> - sending and receiving multiple types of messages.</li>
            </ul>
            </example>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.NamespaceGroupDoc">
            <summary>
            Sending and receiving messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase">
            <summary>
            The abstract class implementing the interface for attaching multiple input channels.
            The class also contains functionality to send (forward) messages via duplex output channels - the duplex input channel
            from the message is forwarded is remembered.
            The duplex output channels used for forwarding are not attached but dynamically created as they are needed.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TConnection">
            <summary>
            Represents the connection between the duplex input channel and the duplex output channel.
            So when the response from the duplex output channel is received it can be forwarded to attached the
            duplex input channel with the correct response receiver id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TDuplexInputChannelContext">
            <summary>
            The context of the duplex input channel consists of the attached duplex input channel and
            it also can contain the list of duplex output channels used to forward the message.
            E.g. The DuplexDispatcher receives the message from the attached duplex input channel and then forwards
            it to all duplex output channels.
            E.g. The DuplexChannelWrapper receives the message from the attached duplex input channel then wrapps
            the message and sends it via the duplex output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.CloseConnections(System.Collections.Generic.IEnumerable{Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TConnection})">
            <summary>
            Closes given connections with client duplex output channel.
            </summary>
            <param name="connections"></param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel">
            <summary>
            Interface for components which want to attach one IDuplexInputChannel.
            </summary>
            <remarks>
            Communication components implementing this interface can attach the duplex input channel and
            receive messages and sends response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel and starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel and stops listening to messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.IsDuplexInputChannelAttached">
            <summary>
            Returns true if the duplex input channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.AttachedDuplexInputChannel">
            <summary>
            Retutns attached duplex input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel">
            <summary>
            Interface for components which want to attach one IDuplexOutputChannel.
            </summary>
            <remarks>
            Communication components implementing this interface can attach the duplex output channel and
            sends messages and receive response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.AttachDuplexOutputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel)">
            <summary>
            Attaches the duplex output channel and opens the connection for listening to response messages.
            </summary>
            <param name="duplexOutputChannel">Duplex output channel to be attached.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.DetachDuplexOutputChannel">
            <summary>
            Detaches the duplex output channel and stops listening to response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.IsDuplexOutputChannelAttached">
            <summary>
            Returns true if the reference to the duplex output channel is stored. <br/>
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.AttachedDuplexOutputChannel">
            <summary>
            Returns attached duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels">
            <summary>
            Interface for components which want to attach multiple IDuplexInputChannel.
            </summary>
            <remarks>
            Communication components implementing this interface can attach multiple duplex input channels and listens via them to messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel nad starts listening to messages.
            </summary>
            <param name="duplexInputChannel">duplex input channel to be attached</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel.
            </summary>
            <remarks>
            Detaching the input channel stops listening to the messages.
            It releases listening threads.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.IsDuplexInputChannelAttached">
            <summary>
            Returns true if the duplex input channel is attached.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel(System.String)">
            <summary>
            Detaches the duplex input channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.AttachedDuplexInputChannels">
            <summary>
            Returns attached input channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.NamespaceDoc">
            <summary>
            Attaching and detaching communication channels.
            </summary>
            <remarks>
            Communication components attach channels in order to be able to send and receive messages.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.NamespaceGroupDoc">
            <summary>
            Attaching channels to communication components.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory">
            <summary>
            Messaging system interacting with an Android device via the USB cable.
            </summary>
            <remarks>
            When Android device is connected to the computer via the USB cable the process adb (Android Debug Bridge) is started
            on the computer and adbd (Android Debug Bridge Daemon) is started on the Android device.
            These processes then communicate via the USB cable.<br/>
            <br/>
            How this messaging works:
            <ol>
            <li>Your desktop application sends a message via the output channel created by AndroidUsbCableMessagingFactory</li>
            <li>The output channel internally sends the message via TCP to the adb service.</li>
            <li>adb service receives data and transfers it via USB cable to adbd.</li>
            <li>adbd in the Android device receives data and forwards it via TCP to the desired port.</li>
            <li>Android application listening on that port receives the message and processes it.</li>
            </ol>
            Notice there is a restrction for this type of communication:<br/>
            The Android application must be a listener (service) and the computer application must be the client.<br/>
            </remarks>
            <example>
            The service on the android side. (implemented in Java)
            <code>
            package eneter.testing;
            
            import eneter.messaging.diagnostic.EneterTrace;
            import eneter.messaging.endpoints.typedmessages.*;
            import eneter.messaging.messagingsystems.messagingsystembase.*;
            import eneter.messaging.messagingsystems.tcpmessagingsystem.TcpMessagingSystemFactory;
            import eneter.net.system.EventHandler;
            import android.app.Activity;
            import android.os.Bundle;
            
            public class AndroidUsbCableServiceActivity extends Activity
            {
                // Eneter communication.
                private IDuplexTypedMessageReceiver&lt;String, String&gt; myEchoReceiver;
                
                
                /** Called when the activity is first created. */
                @Override
                public void onCreate(Bundle savedInstanceState)
                {
                    super.onCreate(savedInstanceState);
                    setContentView(R.layout.main);
                    
                    // Start listening.
                    startListening();
                }
                
                @Override
                public void onDestroy()
                {
                    stopListening();
                    
                    super.onDestroy();
                }
                
                private void startListening()
                {
                    try
                    {
                        // Create message receiver.
                        IDuplexTypedMessagesFactory aReceiverFactory = new DuplexTypedMessagesFactory();
                        myEchoReceiver = aReceiverFactory.createDuplexTypedMessageReceiver(String.class, String.class);
                        
                        // Subscribe to receive messages.
                        myEchoReceiver.messageReceived().subscribe(new EventHandler&lt;TypedRequestReceivedEventArgs&lt;String&gt;&gt;()
                            {
                                @Override
                                public void onEvent(Object sender, TypedRequestReceivedEventArgs&lt;String&gt; e)
                                {
                                    // Response back with the same message.
                                    try
                                    {
                                        myEchoReceiver.sendResponseMessage(e.getResponseReceiverId(), e.getRequestMessage());
                                    }
                                    catch (Exception err)
                                    {
                                        EneterTrace.error("Sending echo response failed.", err);
                                    }
                                }
                            });
                        
                        // Create TCP messaging.
                        // It must listen to IP address 127.0.0.1. You can set desired port e.g. 8090.
                        IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
                        IDuplexInputChannel anInputChannel = aMessaging.createDuplexInputChannel("tcp://127.0.0.1:8090/");
                        
                        // Attach the input channel to the receiver and start listening.
                        myEchoReceiver.attachDuplexInputChannel(anInputChannel);
                    }
                    catch (Exception err)
                    {
                        EneterTrace.error("OpenConnection failed.", err);
                    }
                }
                
                private void stopListening()
                {
                    // Detach input channel and stop listening.
                    myEchoReceiver.detachDuplexInputChannel();
                }
            }
            </code>
            </example>
            
            <example>
            The client application communicating with the Android application via the USB cable.
            <code>
            using System;
            using System.Windows.Forms;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            
            namespace AndroidEchoClient
            {
                public partial class Form1 : Form
                {
                    private IDuplexTypedMessageSender&lt;string, string&gt; myEchoSender;
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        // Echo sender-receiver
                        IDuplexTypedMessagesFactory aSenderFactory = new DuplexTypedMessagesFactory();
                        myEchoSender = aSenderFactory.CreateDuplexTypedMessageSender&lt;string, string&gt;();
            
                        // Subscribe to get the response.
                        myEchoSender.ResponseReceived += OnResponseReceived;
            
                        // Create messaging using the USB cable connected to Android device.
                        IMessagingSystemFactory aMessaging = new AndroidUsbCableMessagingFactory();
            
                        // Create output channel.
                        // It sets the Android application listens to port 8090.
                        IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("8090");
                        myEchoSender.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        myEchoSender.DetachDuplexOutputChannel();
                    }
            
                    private void SendBtn_Click(object sender, EventArgs e)
                    {
                        // Send the message.
                        myEchoSender.SendRequestMessage(TextMessageTextBox.Text);
                    }
            
                    private void OnResponseReceived(object sender, TypedResponseReceivedEventArgs&lt;string&gt; e)
                    {
                        // This is not the UI thread, so
                        // route displaying to the main UI thread.
                        if (InvokeRequired)
                        {
                            Action aUIUpdate = () =&gt; ResponseLabel.Text = e.ResponseMessage;
                            Invoke(aUIUpdate);
                        }
                        else
                        {
                            ResponseLabel.Text = e.ResponseMessage;
                        }
                    }
            
                }
            }
            
            </code>
            </example>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.#ctor">
            <summary>
            Constructs the messaging which communicates with Android via the USB cable.
            </summary>
            <remarks>
            It expects the adb service is running and listening on default port 5037.
            The adb service typically starts automatically when you connect the Android device via the USB cable. 
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.#ctor(System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the messaging which communicates with Android via the USB cable.
            </summary>
            <remarks>
            The adb service typically starts automatically when you connect the Android device via the USB cable. 
            </remarks>
            <param name="adbHostPort">Port where adb service is listening to commands. Default value is 5037.</param>
            <param name="protocolFormatter">Low level formatting used for encoding messages between channels.
            EneterProtocolFormatter() can be used by default.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates duplex output channel which can send and receive messages from the duplex input channel using Android USB cable.
            </summary>
            <remarks>
            <example>
            Using AndroidUsbCableMessagingFactory to create a client on the computer.
            <code>
            // Create messaging using Android USB cable.
            IMessagingSystemFactory aMessaging = new AndroidUsbCableMessagingFactory();
            
            // Create duplex output channel that will communicate via the port 7634.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("7634");
            
            // Create message sender that will send messages.
            ISyncTypedMessagesFactory aSenderFactory = new SyncTypedMessagesFactory();
            ISyncTypedMessageSender aSender = aSenderFactory.CreateSyncMessageSender&lt;string,string&gt;();
            
            // Attach the output channel and be able to send messages and receive responses.
            // Note: It will configure adb to listen on the port 7634 and forward incoming data via the cable
            //       to Android where adbd will forward it to the port 7634.
            aSender.AttachDuplexOutputChannel(anOutputChannel);
            
            // Send message and wait for the response.
            string aResponse = aSender.SendRequestMessage("Hello.");
            ...
            </code>
            Service code on the Android side.
            <code>
            // Create TCP messaging listening on the same port 7634.
            // Note: Use standard TCP messaging, just listen to the specified port.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexInputChannel anInputChannel = aMessaging.createDuplexInputChannel("tcp://127.0.0.1:7634/");
            
            // Create message receiver.
            IDuplexTypedMessagesFactory aReceiverFactory = new DuplexTypedMessagesFactory();
            myReceiver = aReceiverFactory.createDuplexTypedMessageReceiver(String.class, String.class);
            
            // Subscribe to receive messages.
            myReceiver.messageReceived().subscribe(new EventHandler&lt;TypedRequestReceivedEventArgs&lt;String&gt;&gt;()
            {
                @Override
                public void onEvent(Object sender, TypedRequestReceivedEventArgs&lt;String&gt; e)
                {
                    // Response back with the same message.
                    try
                    {
                        myReceiver.sendResponseMessage(e.getResponseReceiverId(), e.getRequestMessage());
                    }
                    catch (Exception err)
                    {
                        EneterTrace.error("Sending echo response failed.", err);
                    }
                }
            });
            
            // Attach the input channel to the receiver and start listening.
            myReceiver.attachDuplexInputChannel(anInputChannel);
            </code>
            </example>
            </remarks>
            <param name="channelId">Port number where the Android application is listening.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates duplex output channel which can send and receive messages from the duplex input channel using Android USB cable.
            </summary>
            <param name="channelId">Port number where the Android application is listening.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Not supported. The known restriction is that Android cannot be client. Therefore, .NET or Java application
            running on PC cannot be a service using the duplex input chanel for listening. :-(
            </summary>
            <param name="channelId"></param>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.SendBufferSize">
            <summary>
            Size of the buffer in bytes for sending messages. Default value is 8192 bytes.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.ReceiveBufferSize">
            <summary>
            Size of the buffer in bytes for receiving messages. Default value is 8192 bytes.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.SendTimeout">
            <summary>
            Sets or gets timeout to send a message.
            </summary>
            <remarks>
            Default is 0 which means infinite time.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.ReceiveTimeout">
            <summary>
            Sets or gets timeout to receive a message.
            </summary>
            <remarks>
            If not received within the time the connection is closed. Default is 0 what it infinite time.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.ConnectTimeout">
            <summary>
            Sets ot gets timeout to open the connection.
            </summary>
            <remarks>
            Default is 30000 miliseconds. Value 0 means infinite time.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.OutputChannelThreading">
            <summary>
            Sets or gets threading mode for output channels.
            </summary>
            <remarks>
            Default setting is that received response messages are routed into one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.NamespaceDoc">
            <summary>
            Communication with Android via the USB cable.
            </summary>
            <example>
            <ul>
                <li><see cref="T:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory"/> - example a simple desktop application communicating with Android service
                 via the USB cable.</li>
            </ul>
            </example>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetLoginMessage">
            <summary>
            Callback providing the login message.
            </summary>
            <remarks>
            Returned login message must be String or byte[].
            </remarks>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <returns>login message (must be String or byte[])</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHanshakeMessage">
            <summary>
            Callback method to get the handshake message.
            </summary>
            <remarks>
            When AuthenticatedDuplexInputChannel receives the login message this callback is called to get
            the handshake message.
            The handshake message is then sent to the connecting AuthenticatedDuplexOutputChannel which will process it
            and send back the handshake response message.<br/>
            <br/>
            Returned handshake message must be String or byte[].
            If it returns null it means the connection will be closed. (e.g. if the login message was not accepted.)
            </remarks>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <param name="loginMessage">login message received from the client</param>
            <returns>handshake message (must be String or byte[])</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHandshakeResponseMessage">
            <summary>
            Callback method to get the response message for the handshake message.
            </summary>
            <remarks>
            When AuthenticatedDuplexOutputChannel receives the handshake message it calls this callback to get
            the response message for the handshake message.
            The response handshake message is then sent to AuthenticatedDuplexInputChannel which will
            then authenticate the connection.<br/>
            <br/>
            Returned response message must be String or byte[].
            If it returns null then it means the handshake message is not accepted and the connection will be closed.
            </remarks>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <param name="handshakeMessage">handshake message received from the service</param>
            <returns>response message (must be String or byte[])</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.Authenticate">
            <summary>
            Callback method to authenticate the connection.
            </summary>
            <remarks>
            When AuthenticatedDuplexInputChannel receives the handshake response message it performs the authentication of the connection.<br/>
            If it returns true the connection will be established.
            If it returns false the connection will be closed.
            </remarks>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <param name="loginMessage">login message that was sent from the client</param>
            <param name="handshakeMessage">verification message (question) that service sent to the client</param>
            <param name="handshakeResponseMessage">client's response to the handshake message</param>
            <returns>true if the authentication passed and the connection can be established.
            If false the authentication failed and the connection will be closed.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.HandleAuthenticationCancelled">
            <summary>
            Callback method to handle when the output channel closes the connection during the authentication sequence.
            </summary>
            <remarks>
            The callback method is called by AuthenticatedDuplexInputChannel when the AuthenticatedDuplexOutputChannel closes the connection during the authentication sequence.
            It allows the user code to detect a canceled authentication and clean resources.
            </remarks>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <param name="loginMessage">login message that was sent from the client</param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory">
            <summary>
            Extension for authentication during connecting.
            </summary>
            <remarks>
            Here is how the authentication procedure works:
            <ol>
            <li>AuthenticatedDuplexOutputChannel calls getLoginMessage callback and gets the login message. Then
                sends it to AuthenticatedDuplexInputChannel.</li>
            <li>AuthenticatedDuplexInputChannel receives the login message and calls getHandshakeMessage callback.
                The returned handshake message is sent to AuthenticatedDuplexOutputChannel.</li>
            <li>AuthenticatedDuplexOutputChannel receives the handshake message and calls getHandshakeResponseMessage.
                The returned handshake response message is then sent to AuthenticatedDuplexInputChannel.</li>
            <li>AuthenticatedDuplexInputChannel receives the handshake response message and calls authenticate callback.
                if it returns true the connection is established.</li>
            </ol>
            
            <example>
            Service side using the authentication:
            <code>
            class Program
            {
                private static Dictionary&lt;string, string&gt; myUsers = new Dictionary&lt;string, string&gt;();
                private static IDuplexStringMessageReceiver myReceiver;
            
                static void Main(string[] args)
                {
                    //EneterTrace.TraceLog = new StreamWriter("d:/tracefile.txt");
            
                    // Simulate users.
                    myUsers["John"] = "password1";
                    myUsers["Steve"] = "password2";
            
                    // Create TCP based messaging.
                    IMessagingSystemFactory aTcpMessaging = new TcpMessagingSystemFactory();
            
                    // Connecting clients will be authenticated.
                    IMessagingSystemFactory aMessaging = new AuthenticatedMessagingFactory(aTcpMessaging, GetHandshakeMessage, Authenticate);
                    IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:8092/");
            
                    // Use text messages.
                    IDuplexStringMessagesFactory aStringMessagesFactory = new DuplexStringMessagesFactory();
                    myReceiver = aStringMessagesFactory.CreateDuplexStringMessageReceiver();
                    myReceiver.RequestReceived += OnRequestReceived;
            
                    // Attach input channel and start listening.
                    // Note: using AuthenticatedMessaging will ensure the connection will be established only
                    //       if the authentication procedure passes.
                    myReceiver.AttachDuplexInputChannel(anInputChannel);
            
                    Console.WriteLine("Service is running. Press Enter to stop.");
                    Console.ReadLine();
            
                    // Detach input channel and stop listening.
                    // Note: tis will release the listening thread.
                    myReceiver.DetachDuplexInputChannel();
                }
            
                private static void OnRequestReceived(object sender, StringRequestReceivedEventArgs e)
                {
                    // Handle received messages here.
                    Console.WriteLine(e.RequestMessage);
            
                    // Send back the response.
                    myReceiver.SendResponseMessage(e.ResponseReceiverId, "Hello");
                }
            
                private static object GetHandshakeMessage(string channelId, string responseReceiverId, object loginMessage)
                {
                    // Check if login is ok.
                    if (loginMessage is string)
                    {
                        string aLoginName = (string)loginMessage;
                        if (myUsers.ContainsKey(aLoginName))
                        {
                            // Login is OK so generate the handshake message.
                            // e.g. generate GUI.
                            return Guid.NewGuid().ToString();
                        }
                    }
                    
                    // Login was not ok so there is not handshake message
                    // and the connection will be closed.
                    EneterTrace.Warning("Login was not ok. The connection will be closed.");
                    return null;
                }
            
                private static bool Authenticate(string channelId, string responseReceiverId, object loginMessage,
                    object handshakeMessage, object handshakeResponseMessage)
                {
                    if (loginMessage is string)
                    {
                        // Get the password associated with the user.
                        string aLoginName = (string) loginMessage;
                        string aPassword;
                        myUsers.TryGetValue(aLoginName, out aPassword);
                        
                        // E.g. handshake response may be encrypted original handshake message.
                        //      So decrypt incoming handshake response and check if it is equal to original handshake message.
                        try
                        {
                            ISerializer aSerializer = new AesSerializer(aPassword);
                            string aDecodedHandshakeResponse = aSerializer.Deserialize&lt;string&gt;(handshakeResponseMessage);
                            string anOriginalHandshake = (string) handshakeMessage;
                            if (anOriginalHandshake == aDecodedHandshakeResponse)
                            {
                                // The handshake response is correct so the connection can be established.
                                return true;
                            }
                        }
                        catch (Exception err)
                        {
                            // Decoding of the response message failed.
                            // The authentication will not pass.
                            EneterTrace.Warning("Decoding handshake message failed.", err);
                        }
                    }
                    
                    // Authentication did not pass.
                    EneterTrace.Warning("Authentication did not pass. The connection will be closed.");
                    return false;
                }
            }
            </code>
            </example>
            
            <example>
            Client using the authentication:
            <code>
            class Program
            {
                private static IDuplexStringMessageSender mySender;
            
                static void Main(string[] args)
                {
                    // TCP messaging.
                    IMessagingSystemFactory aTcpMessaging = new TcpMessagingSystemFactory();
                
                    // Authenticated messaging uses TCP as the underlying messaging.
                    IMessagingSystemFactory aMessaging = new AuthenticatedMessagingFactory(aTcpMessaging, GetLoginMessage, GetHandshakeResponseMessage);
                    IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8092/");
                
                    // Use text messages.
                    mySender = new DuplexStringMessagesFactory().CreateDuplexStringMessageSender();
                
                    // Subscribe to receive response messages.
                    mySender.ResponseReceived += OnResponseMessageReceived;
                
                    // Attach output channel and connect the service.
                    mySender.AttachDuplexOutputChannel(anOutputChannel);
                
                    // Send a message.
                    mySender.SendMessage("Hello");
                
                    Console.WriteLine("Client sent the message. Press ENTER to stop.");
                    Console.ReadLine();
                
                    // Detach output channel and stop listening.
                    // Note: it releases the tread listening to responses.
                    mySender.DetachDuplexOutputChannel();
                }
            
                private static void OnResponseMessageReceived(object sender, StringResponseReceivedEventArgs e)
                {
                    // Process the incoming response here.
                    Console.WriteLine(e.ResponseMessage);
                }
            
                public static object GetLoginMessage(string channelId, string responseReceiverId)
                {
                    return "John";
                }
            
                public static object GetHandshakeResponseMessage(string channelId, string responseReceiverId, object handshakeMessage)
                {
                    try
                    {
                        // Handshake response is encoded handshake message.
                        ISerializer aSerializer = new AesSerializer("password1");
                        object aHandshakeResponse = aSerializer.Serialize&lt;string&gt;((string)handshakeMessage);
                        
                        return aHandshakeResponse;
                    }
                    catch (Exception err)
                    {
                        EneterTrace.Warning("Processing handshake message failed. The connection will be closed.", err);
                    }
                    
                    return null;
                }
            }
            </code>
            </example>
            
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetLoginMessage,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHandshakeResponseMessage)">
            <summary>
            Constructs factory that will be used only by a client.
            </summary>
            <remarks>
            The constructor takes only callbacks which are used by the client. Therefore if you use this constructor
            you can create only duplex output channels.
            </remarks>
            <param name="underlyingMessagingSystem">underlying messaging upon which the authentication will work.</param>
            <param name="getLoginMessageCallback">callback called by the output channel to get the login message which shall be used to open the connection</param>
            <param name="getHandshakeResponseMessageCallback">callback called by the output channel to get the response for the handshake message which was received from the input channel.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHanshakeMessage,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.Authenticate)">
            <summary>
            Constructs factory that will be used only by a service.
            </summary>
            <remarks>
            The constructor takes only callbacks which are used by the service. Therefore if you use this constructor
            you can create only duplex input channels.
            </remarks>
            <param name="underlyingMessagingSystem">underlying messaging upon which the authentication will work.</param>
            <param name="getHandshakeMessageCallback">callback returning the handshake message.</param>
            <param name="authenticateCallback">callback performing the authentication.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHanshakeMessage,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.Authenticate,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.HandleAuthenticationCancelled)">
            <summary>
            Constructs factory that will be used only by a service.
            </summary>
            <remarks>
            The constructor takes only callbacks which are used by the service. Therefore if you use this constructor
            you can create only duplex input channels.
            </remarks>
            <param name="underlyingMessagingSystem">underlying messaging upon which the authentication will work.</param>
            <param name="getHandshakeMessageCallback">callback called by the input chanel to get the handshake message for the login message which was received from the output channel.</param>
            <param name="authenticateCallback">callback called by the input channe to perform the authentication.</param>
            <param name="handleAuthenticationCancelledCallback">callback called by the input channel to indicate the output channel closed the connection during the authentication procedure.
            Can be null if your authentication code does not need to handle it.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetLoginMessage,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHandshakeResponseMessage,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHanshakeMessage,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.Authenticate,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.HandleAuthenticationCancelled)">
            <summary>
            Constructs factory that can be used by client and service simultaneously.
            </summary>
            <remarks>
            If you construct the factory with this constructor you can create both duplex output channels and
            duplex input channels.
            </remarks>
            <param name="underlyingMessagingSystem">underlying messaging upon which the authentication will work.</param>
            <param name="getLoginMessageCallback">callback called by the output channel to get the login message which shall be used to open the connection</param>
            <param name="getHandshakeResponseMessageCallback">callback called by the output channel to get the response for the handshake message which was received from the input channel.</param>
            <param name="getHandshakeMessageCallback">callback called by the input chanel to get the handshake message for the login message which was received from the output channel.</param>
            <param name="authenticateCallback">callback called by the input channe to perform the authentication.</param>
            <param name="handleAuthenticationCancelledCallback">callback called by the input channel to indicate the output channel closed the connection during the authentication procedure.
            Can be null if your authentication code does not need to handle it.
            (E.g. if the authentication logic needs to clean if the authentication fails.)</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates duplex output channel which performs authentication procedure during opening the connection.
            </summary>
            <remarks>
            The created authenticated output channel can throw following exceptions when opening the connection:
            <ul>
            <li>TimeOutException - if the authentication sequence exceeds the specified AuthenticationTimeout.</li>
            <li>InvalidOperationException - if the authentication fails and the conneciton is not granted.</li>
            <li>Other underlying messaging specific exception - if it fails to open the connection and start the authentication.</li>
            </ul>
            </remarks>
            <param name="channelId">service address</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates duplex output channel which performs authentication procedure during opening the connection.
            </summary>
            <remarks>
            The created authenticated output channel can throw following exceptions when opening the connection:
            <ul>
            <li>TimeOutException - if the authentication sequence exceeds the specified AuthenticationTimeout.</li>
            <li>AuthenticationException - if the authentication fails and the conneciton is not granted.</li>
            <li>Other underlying messaging specific exception - if it fails to open the connection and start the authentication.</li>
            </ul>
            </remarks>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique identifier of the connection with the service.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates duplex input channel which performs the authentication procedure.
            </summary>
            <param name="channelId">service address</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.AuthenticationTimeout">
            <summary>
            Gets/sets maximum time until the authentication procedure must be performed.
            </summary>
            <remarks>
            The timeout is applied in duplex output channel. If the authentication is not completed within the specified time
            TimeoutException is thrown.<br/>
            Timeout is set to 30 seconds by default.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.OutputChannelThreading">
            <summary>
            Gets or sets the threading mode for the authenticated output channel.
            </summary>
            <remarks>
            When opening connection the authenticated output channel communicates with the authenticated input channel.
            During this communication the openConnection() is blocked until the whole authentication communication is performed.
            It means if openConnection() is called from the same thread into which the underlying duplex output channel
            routes events the openConneciton() would get into the deadusing (ThreadLock.Lock(because the underlying output channel would
            route authentication messages into the same thread).<br/>
            <br/>
            Therefore it is possible to set the threading mode of the authenticated output channel independently. 
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.NamespaceDoc">
            <summary>
            Extension for client authentication.
            </summary>
            <remarks>
            Provides extension to authenticate the connection.
            If the authentication passes the connection is established.
            If the authentication fails the connection is closed.
            <example>
            <ul>
            <li><see cref="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory"/> - client authenticated when connected</li>
            </ul>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory">
            <summary>
            Extension allowing to work offline until the connection is available.
            </summary>
            <remarks>
            The buffered messaging is intended to overcome relatively short time intervals when the connection is not available.
            It means the buffered messaging is able to hide unavailable connection and work offline while
            trying to reconnect.<br/>
            If the connection is not available, the buffered messaging stores sent messages (and sent response messages)
            in the buffer and sends them when the connection is established.<br/>
            <b>Note:</b><br/>
            The buffered messaging does not require that both communicating parts create channels with buffered messaging factory.
            It means, e.g. the duplex output channel created with buffered messaging with underlying TCP, can send messages
            directly to the duplex input channel created with just TCP messaging factory.<br/>
            <br/>
            <example>
            The following example shows how to use buffered messaging e.g. if the connection can get temporarily lost:
            <code>
            // Create TCP messaging.
            IMessagingSystemFactory anUnderlyingMessaging = new TcpMessagingSystemFactory();
            
            // Create buffered messaging that internally uses TCP.
            IMessagingSystemFactory aMessaging = new BufferedMessagingSystemFactory(anUnderlyingMessaging);
            
            // Create the duplex output channel.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8045/");
            
            // Create message sender to send simple string messages.
            IDuplexStringMessagesFactory aSenderFactory = new DuplexStringMessagesFactory();
            IDuplexStringMessageSender aSender = aSenderFactory.CreateDuplexStringMessageSender();
            
            // Subscribe to receive responses.
            aSender.ResponseReceived += OnResponseReceived;
            
            // Attach output channel an be able to send messages and receive responses.
            aSender.AttachDuplexOutputChannel(anOutputChannel);
            
            ...
            
            // Send a message. If the connection was broken the message will be stored in the buffer.
            // Note: The buffered messaging will try to reconnect automatically.
            aSender.SendMessage("Hello.");
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The maximum offline time will be set to 10 seconds.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. Websocket, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,System.TimeSpan)">
            <summary>
            Constructs the factory from the specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. Websocket, TCP, ...</param>
            <param name="maxOfflineTime">the max time, the communicating applications can be disconnected</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the output channel which can send messages to the input channel and receive response messages.
            </summary>
            <remarks>
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            Then when the connection is established, the messages are sent from the buffer.
            If the reconnect is not successful within the maximum offline time, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> and messages
            are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>buffered duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the output channel which can send messages to the input channel and receive response messages.
            </summary>
            <remarks>
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            Then when the connection is established, the message are sent from the buffer.
            If the reconnect is not successful within the maximum offline time, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> and messages
            are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">response receiver id of this duplex output channel</param>
            <returns>buffered duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the input channel which can receive messages from the output channel and send response messages.
            </summary>
            <remarks>
            If the connection with the duplex output channel is not established, it puts sent response messages to the buffer.
            Then, when the duplex input channel is connected, the response messages are sent.
            If the duplex output channel does not connect within the specified maximum offline time, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/> is invoked and response messages are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>buffered duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.IBufferedDuplexInputChannel">
            <summary>
            Duplex input channel which can work offline.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.IBufferedDuplexInputChannel.ResponseReceiverOnline">
            <summary>
            The event is raised when a response receiver gets into the online state.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.IBufferedDuplexInputChannel.ResponseReceiverOffline">
            <summary>
            The event is raised when a response receiver gets into the offline state.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.IBufferedDuplexOutputChannel">
            <summary>
            Duplex output channel which can work offline.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.IBufferedDuplexOutputChannel.ConnectionOnline">
            <summary>
            The event is raised when the connection gets into the online state.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.IBufferedDuplexOutputChannel.ConnectionOffline">
            <summary>
            The event is raised when the connection gets into the offline state.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.IBufferedDuplexOutputChannel.IsOnline">
            <summary>
            Returns true if the connection is in the online state.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.NamespaceDoc">
            <summary>
            Extension for automatic reconnect and buffering of sent messages in case of a disconnection.
            </summary>
            <remarks>
            The buffered messaging is intended to temporarily store sent messages until the network connection is established.<br/>
            Typical scenarios are:
            <br/><br/>
            <b>Short disconnections</b><br/>
            In case of unstable network the connection can be broken. Buffered messaging will try to recover the broken connection
            and meanwhile it will store sent messages to the buffer. Then when the connection is reopen it will send messages from
            the buffer.
            <br/><br/>
            <b>Independent startup order</b><br/>
            In case your SW system consists of multiple applications which need to communicate it can be problematic
            to start them in a certain order so that communicating parts are available.
            To get rid of the startup order dependency you can use the buffered messaging. If messages are sent
            to an application which is not started yet they will be stored in the buffer until the application is started.
            
            
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory">
            <summary>
            This messaging combines buffered and monitored messaging.
            </summary>
            <remarks>
            Monitored messaging constantly monitors the connection and if the disconnection is detected the buffered messaging
            is notified. Buffered messaging then tries to reconnect and meanwhile stores all sent messages into a buffer.
            Once the connection is recovered the messages stored in the buffer are sent.<br/>
            <br/>
            The buffered monitored messaging is composed from following messagings:
            <ul>
            <li><i>BufferedMessaging</i> is on the top and is responsible for storing of messages during the disconnection (offline time)
            and automatic reconnect.</li>
            <li><i>MonitoredMessaging</i> is in the middle and is responsible for continuous monitoring of the connection.</li>
            <li><i>UnderlyingMessaging</i> (e.g. TCP) is on the bottom and is responsible for sending and receiving messages.</li>
            </ul>
            The following example shows how to create BufferedMonitoredMessaging:
            <example>
            <code>
            // Create TCP messaging system.
            IMessagingSystemFactory anUnderlyingMessaging = new TcpMessagingSystemFactory();
            
            // Create buffered monitored messaging which takes TCP as underlying messaging.
            IMessagingSystemFactory aMessaging = new BufferedMonitoredMessagingFactory(anUnderlyingMessaging);
            
            // Then creating channels which can be then attached to communication components.
            IDuplexInputChannel anInputChannel = aMessaging.createDuplexInputChannel("tcp://127.0.0.1:8095/");
            IDuplexInputChannel anOutputChannel = aMessaging.createDuplexOutputChannel("tcp://127.0.0.1:8095/");
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            The maximum offline time for buffered messaging is set to 10 seconds.
            The ping frequency for monitored messaging is set to 1 second and the receive timeout for monitored messaging
            is set to 2 seconds.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory with the specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. TCP</param>
            <param name="maxOfflineTime">the maximum time, the messaging can work offline. When the messaging works offline,
            the sent messages are buffered and the connection is being reopened. If the connection is
            not reopen within maxOfflineTime, the connection is closed.
            </param>
            <param name="pingFrequency">how often the connection is checked with the 'ping' requests.</param>
            <param name="pingResponseTimeout">the maximum time, the response for the 'ping' is expected.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the output channel which can send and receive messages.
            </summary>
            <remarks>
            This duplex output channel provides the buffered messaging and the connection monitoring.
            It regularly checks if the connection is available. It sends 'ping' requests and expects 'ping' responses
            within the specified time. If the 'ping' response does not come the disconnection is notified to the buffered messaging.
            The buffered messaging then tries to reconnect and meanwhile stores the sent messages to the buffer.
            Once the connection is recovered the messages stored in the buffer are sent.
            If the connection recovery was not possible the event IDuplexOutputChannel.ConnectionClosed
            is raised the message buffer is deleted.
            </remarks>
            <param name="channelId">input channel address. The syntax must comply to underlying messaging</param>
            <returns>buffered and monitored duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the output channel which can send and receive messages.
            </summary>
            <remarks>
            This duplex output channel provides the buffered messaging and the connection monitoring.
            It regularly checks if the connection is available. It sends 'ping' requests and expects 'ping' responses
            within the specified time. If the 'ping' response does not come the disconnection is notified to the buffered messaging.
            The buffered messaging then tries to reconnect and meanwhile stores the sent messages to the buffer.
            Once the connection is recovered the messages stored in the buffer are sent.
            If the connection recovery was not possible the event IDuplexOutputChannel.ConnectionClosed
            is raised the message buffer is deleted.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">the unique id of this response receiver</param>
            <returns>buffered and monitored duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the input channel which can receive and send messages.
            </summary>
            <remarks>
            This duplex input channel provides the buffered messaging and the connection monitoring.
            It regularly checks if the duplex output channel is still connected. It expect, that every connected duplex output channel
            sends regularly 'ping' messages. If the 'ping' message from the duplex output channel is not received within the specified
            time the duplex output channel is disconnected and the buffered messaging is notified about the disconnection.
            The buffered messaging then puts all sent response messages to the buffer and waits whether the duplex output channel reconnects.
            If the duplex output channel reopens the connection the messages stored in the buffer are sent.
            If the duplex output channel does not reconnect the event
            IDuplexInputChannel.ResponseReceiverDisconnected is raised and response messages are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>buffered and monitored duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.BufferedMessaging">
            <summary>
            Returns underlying buffered messaging.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.MonitoredMessaging">
            <summary>
            Returns underlying monitored messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus">
            <summary>
            Message bus.
            </summary>
            <remarks>
            The message bus is the component which can expose services.
            The service connects the message bus and registers its service id.
            When a client needs to use the service it connects the message bus and specifies the service id.
            If the service id exists the message bus establishes the connection between the client and the service.<br/>
            <br/>
            The presence of the message bus is transparent for logic of services and their clients. The whole communication
            is realized via <see cref="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory"/> which ensures the interaction with the message bus.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.ServiceRegistered">
            <summary>
            The event is raised when a new service is registered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.ServiceUnregistered">
            <summary>
            The event is raised when a service is unregistered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.ClientConnected">
            <summary>
            The event is raised when a client is connected to the service.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.ClientDisconnected">
            <summary>
            The event is raised when a client is disconnected from the service.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.MessageToServiceSent">
            <summary>
            The event is raised when a client sent a message to the service.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.MessageToClientSent">
            <summary>
            The event is raised when a service sent a message to the client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.AttachDuplexInputChannels(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel,Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches input channels which are used for the communication with the message bus.
            </summary>
            <remarks>
            Once input channels are attached the message bus is listening and can be used by services and
            clients.
            </remarks>
            <param name="serviceInputChannel">channel used by services for registering their services in the message bus</param>
            <param name="clientInputChannel">channel used by clients for connecting services via the message bus.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.DetachDuplexInputChannels">
            <summary>
            Detaches input channels and stops the listening.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.ConnectedServices">
            <summary>
            Returns list of all connected services.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.GetConnectedClients(System.String)">
            <summary>
            Returns list of all clients connected to the specified service.
            </summary>
            <param name="serviceAddress">id of the service</param>
            <returns>sequence of response receiver ids representing clients</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.GetNumberOfConnectedClients(System.String)">
            <summary>
            Returns number of clients connected to the specified service.
            </summary>
            <remarks>
            Using this method is faster than GetConnectedClients because it does not have to copy data.
            </remarks>
            <param name="serviceAddress">id of the service</param>
            <returns>number of connected clients</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.DisconnectService(System.String)">
            <summary>
            Disconnect and unregisters the specified service.
            </summary>
            <param name="serviceAddress">id of the service that shall be unregistered</param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBusFactory">
            <summary>
            Creates the message bus.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBusFactory.CreateMessageBus">
            <summary>
            Instantiates the message bus.
            </summary>
            <returns>message bus</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusClientEventArgs">
            <summary>
            Event arguments used by the message bus when a client is connected/disconnected.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusClientEventArgs.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the event arguments.
            </summary>
            <param name="serviceAddress">id of service</param>
            <param name="serviceResponseReceiverId">response receiver id of the service.</param>
            <param name="clientResponseReceiverId">response receiver id of the client.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusClientEventArgs.ServiceAddress">
            <summary>
            Returns service id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusClientEventArgs.ServiceResponseReceiverId">
            <summary>
            Rrturns response receiver id of the service.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusClientEventArgs.ClientResponseReceiverId">
            <summary>
            Returns response receiver id of the client.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusFactory">
            <summary>
            Implements factory for creating the message bus.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusFactory.#ctor">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            It uses internal MessageBusCustomSerializer which is optimazed to serialize/deserialze only the MessageBusMessage.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Construct the factory.
            </summary>
            <param name="serializer">Serializer which will be used to serialize/deserialize MessageBusMessage.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusFactory.CreateMessageBus">
            <summary>
            Instantiates the message bus.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.EMessageBusRequest">
            <summary>
            Internal commands for interaction with the message bus.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MessageBus.EMessageBusRequest.RegisterService">
            <summary>
            Used by service when registering to the message bus.
            </summary>
            <remarks>
            MessageBusMessage Id parameter is service id which shall be registered.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MessageBus.EMessageBusRequest.ConnectClient">
            <summary>
            Used by client when connecting the service via the message bus.
            </summary>
            <remarks>
            MessageBusMessage Id parameter is service id which shall be connected.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MessageBus.EMessageBusRequest.DisconnectClient">
            <summary>
            Used by service when it wants to disconnect a particular client.
            </summary>
            <remarks>
            MessageBusMessage Id parameter is client id which shall be disconnected.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MessageBus.EMessageBusRequest.ConfirmClient">
            <summary>
            Used by service when it confirms the client was connected.
            </summary>
            <remarks>
            MessageBusMessage Id parameter is client id which was connected to the service.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MessageBus.EMessageBusRequest.SendRequestMessage">
            <summary>
            Used by client when sending a message to the service.
            </summary>
            <remarks>
            MessageBusMessage Id parameter is client id which sent the message to the service.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MessageBus.EMessageBusRequest.SendResponseMessage">
            <summary>
            Used by service when sending message to the client.
            </summary>
            <remarks>
            MessageBusMessage Id parameter is client id which shall receive the message.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessage">
            <summary>
            Internal message for interaction with the message bus.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessage.#ctor">
            <summary>
            Default constructor available for deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessage.#ctor(Eneter.Messaging.MessagingSystems.Composites.MessageBus.EMessageBusRequest,System.String,System.Object)">
            <summary>
            Constructs the message.
            </summary>
            <param name="request">Requested from the message bus.</param>
            <param name="id">Depending on the request it is client id or service id.</param>
            <param name="messageData">If the request is SendRequestMessage or SendResponseMessage it is the serialized message data.
            Otherwise it is null.
            </param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessage.Request">
            <summary>
            Request for the message bus.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessage.Id">
            <summary>
            Depending on the request it is client id or service id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessage.MessageData">
            <summary>
            If the request is SendRequestMessage or SendResponseMessage it contains the serialized message data
            which is sent between client and service. 
            Otherwise it is null.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessageEventArgs">
            <summary>
            Event arguments used by message when a message was transferred to a service or to a client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessageEventArgs.#ctor(System.String,System.String,System.String,System.Object)">
            <summary>
            Constructs the event arguments.
            </summary>
            <param name="serviceAddress">id of service.</param>
            <param name="serviceResponseReceiverId">response receiver id of the service.</param>
            <param name="clientResponseReceiverId">response receiver id of the client.</param>
            <param name="message">message which is sent from client to service or from service to client.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessageEventArgs.ServiceAddress">
            <summary>
            Returns service id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessageEventArgs.ServiceResponseReceiverId">
            <summary>
            Returns response receiver id of the service.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessageEventArgs.ClientResponseReceiverId">
            <summary>
            Returns response receiver id of the client.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessageEventArgs.Message">
            <summary>
            Returns message which is between client and service.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory">
            <summary>
            Extension providing the communication via the message bus.
            </summary>
            <remarks>
            This messaging provides the client-service communication via the message bus.
            It ensures the communication via the message bus is transparent and for communicating parts it looks like a normal
            communication via output and input channel.<br/>
            The duplex input channel created by this messaging will automatically connect the message bus and register the service
            when the StartListening() is called.<br/>
            The duplex output channel created by this messaging will automatically connect the message bus and ask for the service
            when the OpenConnection() is called.<br/>
            <br/>
            The following example shows how to communicate via the message bus.
            
            <example>
            Implementation of the message bus service that will mediate the client-service communication:
            <code>
            class Program
                {
                    static void Main(string[] args)
                    {
                        // Message Bus will use TCP for the communication.
                        IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
                    
                        // Input channel to listen to services.
                        IDuplexInputChannel aServiceInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:8045/");
                    
                        // Input channel to listen to clients.
                        IDuplexInputChannel aClientInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:8046/");
                    
                        // Create the message bus.
                        IMessageBus aMessageBus = new MessageBusFactory().CreateMessageBus();
                    
                        // Attach channels to the message bus and start listening.
                        aMessageBus.AttachDuplexInputChannels(aServiceInputChannel, aClientInputChannel);
                    
                        Console.WriteLine("Message bus service is running. Press ENTER to stop.");
                        Console.ReadLine();
                    
                        // Detach channels and stop listening.
                        aMessageBus.DetachDuplexInputChannels();
                    }
                }
            </code>
            </example>
            
            <example>
            Implementation of the service which is exposed via the message bus:
            <code>
            public interface IEcho
            {
                string hello(string text);
            }
            
            ....
            
            internal class EchoService : IEcho
            {
                public string hello(string text)
                {
                    return text;
                }
            }
            
            ....
            
            class Program
            {
                static void Main(string[] args)
                {
                    // The service will communicate via Message Bus which is listening via TCP.
                    IMessagingSystemFactory aMessageBusUnderlyingMessaging = new TcpMessagingSystemFactory();
                    // note: only TCP/IP address which is exposed for services is needed.
                    IMessagingSystemFactory aMessaging = new MessageBusMessagingFactory("tcp://127.0.0.1:8045/", null, aMessageBusUnderlyingMessaging);
                
                    // Create input channel listening via the message bus.
                    // Note: this is address of the service inside the message bus.
                    IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("Eneter.Echo");
                
                    // Instantiate class implementing the service.
                    IEcho anEcho = new EchoService();
                
                    // Create the RPC service.
                    IRpcService&lt;IEcho&gt; anEchoService = new RpcFactory().CreateService&lt;IEcho&gt;(anEcho);
                
                    // Attach input channel to the service and start listening via the message bus.
                    anEchoService.AttachDuplexInputChannel(anInputChannel);
                
                    Console.WriteLine("Echo service is running. Press ENTER to stop.");
                    Console.ReadLine();
                
                    // Detach the input channel and stop listening.
                    anEchoService.DetachDuplexInputChannel();
                }
            }
            </code>
            </example>
            
            <example>
            Implementation of the client using the service which is exposed via the message bus:
            <code>
            class Program
            {
                static void Main(string[] args)
                {
                    // The client will communicate via Message Bus which is listening via TCP.
                    IMessagingSystemFactory aMessageBusUnderlyingMessaging = new TcpMessagingSystemFactory();
                    // note: only TCP/IP address which is exposed for clients is needed. 
                    IMessagingSystemFactory aMessaging = new MessageBusMessagingFactory(null, "tcp://127.0.0.1:8046/", aMessageBusUnderlyingMessaging);
                
                    // Create output channel that will connect the service via the message bus..
                    // Note: this is address of the service inside the message bus.
                    IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("Eneter.Echo");
                
                    // Create the RPC client for the Echo Service.
                    IRpcClient&lt;IEcho&gt; aClient = new RpcFactory().CreateClient&lt;IEcho&gt;();
                
                    // Attach the output channel and be able to communicate with the service via the message bus.
                    aClient.AttachDuplexOutputChannel(anOutputChannel);
                
                    // Get the service proxy and call the echo method.
                    IEcho aProxy = aClient.Proxy;
                    String aResponse = aProxy.hello("hello");
                
                    Console.WriteLine("Echo service returned: " + aResponse);
                    Console.WriteLine("Press ENTER to stop.");
                    Console.ReadLine();
                
                    // Detach the output channel.
                    aClient.DetachDuplexOutputChannel();
                }
            }
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.#ctor(System.String,System.String,Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory.
            </summary>
            <remarks>
            Message bus instantiated using this constructor will use MessageBusCustom serializer which is optimized to serialize/deserialize
            only MessageBusMessage used for the communication with the message bus.
            </remarks>
            <param name="serviceConnctingAddress">message bus address intended for services which want to register in the message bus.
            It can be null if the message bus factory is intended to create only duplex output channels.</param>
            <param name="clientConnectingAddress">clientConnectingAddress message bus address intended for clients which want to connect a registered service.
            It can be null if the message bus factory is intended to create only duplex input channels.</param>
            <param name="underlyingMessaging">messaging system used by the message bus.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.#ctor(System.String,System.String,Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="serviceConnectingAddress">message bus address intended for services which want to register in the message bus.
            It can be null if the message bus factory is intended to create only duplex output channels.</param>
            <param name="clientConnectingAddress">clientConnectingAddress message bus address intended for clients which want to connect a registered service.
            It can be null if the message bus factory is intended to create only duplex input channels.</param>
            <param name="underlyingMessaging">messaging system used by the message bus.</param>
            <param name="serializer">serializer which is used to serialize {@link MessageBusMessage} which is internally used for the communication with
            the message bus. If null then custom message bus serializer is used.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.#ctor(System.String,System.String,Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="serviceConnectingAddress">message bus address intended for services which want to register in the message bus.
            It can be null if the message bus factory is intended to create only duplex output channels.</param>
            <param name="clientConnectingAddress">clientConnectingAddress message bus address intended for clients which want to connect a registered service.
            It can be null if the message bus factory is intended to create only duplex input channels.</param>
            <param name="serviceUnderlyingMessaging">underlying messaging used for services which connect the message bus to expose services.
            It can be null if the message bus factory is intended to create only duplex output channels.</param>
            <param name="clientUnderlyingMessaging">underlying messaging used for clients which connect the message bus to consume an exposed service.
            It can be null if the message bus factory is intended to create only duplex input channels.</param>
            <param name="serializer">serializer which is used to serialize {@link MessageBusMessage} which is internally used for the communication with
            the message bus. If null then custom message bus serializer is used.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates duplex output channel.
            </summary>
            <remarks>
            Channel id represents the logical address of the service inside the message bus. E.g. "Eneter.EchoService".
            </remarks>
            <param name="channelId">logical address of the service inside the message bus</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates duplex output channel.
            </summary>
            <remarks>
            Channel id represents the logical address of the service inside the message bus. E.g. "Eneter.EchoService".
            </remarks>
            <param name="channelId">logical address of the service inside the message bus</param>
            <param name="responseReceiverId">unique id representing the client</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates duplex input channel.
            </summary>
            <remarks>
            Channel id represents the logical address of the service inside the message bus. E.g. "Eneter.EchoService".
            </remarks>
            <param name="channelId">logical address of the service inside the message bus</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.ClientMessaging">
            <summary>
            Get or set the messaging used by clients to connect the message bus.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.ServiceMessaging">
            <summary>
            Get or set the messaging used by services to be exposed via the message bus.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.InputChannelThreading">
            <summary>
            Provides thread dispatcher responsible for routing events from duplex input channel according to
            desired threading model.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed one by one via a working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.OutputChannelThreading">
            <summary>
            Provides thread dispatcher responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed one by one via a working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.ConnectTimeout">
            <summary>
            Maximum time for opening connection with the service via the message bus. Default value is 30 seconds.
            </summary>
            <remarks>
            When the client opens the connection with a service via message bus it requests message bus to open connection
            with a desired service. The message checks if the requested service exists and if yes it forwards the open connection request.
            Then when the service receives the open connection request it sends back the confirmation message that the client is connected.
            This timeout specifies the maximum time which is allowed for sending the open connection request and receiving the confirmation from the service.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusServiceEventArgs">
            <summary>
            Event arguments used by the message bus when a service is connected / disconnected.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusServiceEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event arguments.
            </summary>
            <param name="serviceAddress">service id.</param>
            <param name="responseReceiverId">response receiver id of the service.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusServiceEventArgs.ServiceAddress">
            <summary>
            Returns service id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusServiceEventArgs.ResponseReceiverId">
            <summary>
            Returns response receiver id of the service.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.NamespaceDoc">
            <summary>
            Extension for communication via the message bus.
            </summary>
            <remarks>
            The message bus is the component that can be used to expose multiple services from one place.
            It means when a service wants to expose its functionality it connects the message bus and registers its service id.
            Then when a client wants to use the service it connects the message bus and asks for the service using the service id.
            Message bus is then responsible to establish the connection between the client and the service.<br/>
            This extension hides the communication is running via the message bus. For communicating parts it looks as if they
            communicate directly.
            <example>
            For more details see examples:
            <ul>
                <li><see cref="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory"/> - exposing a simple service via the message bus.</li>
            </ul>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType">
            <summary>
            Type of the message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType.Ping">
            <summary>
            Indicates, it is the ping message or ping response.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType.Message">
            <summary>
            Indicates, it is a regular data message between output and input channel. 
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage">
            <summary>
            Internal message used for the communication between output and input channels in monitored messaging.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.#ctor">
            <summary>
            Constructs the message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.#ctor(Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType,System.Object)">
            <summary>
            Constructs the message from specified parameters.
            </summary>
            <param name="messageType">type of the message, ping or regular message</param>
            <param name="messageContent">message content, in case of ping this parameter is not used</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.MessageType">
            <summary>
            Type of the message. Ping or regular message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.MessageContent">
            <summary>
            Serialized data message.
            </summary>
            <remarks>
            In case of 'ping', this property is null.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory">
            <summary>
            Extension providing the connection monitoring.
            </summary>
            <remarks>
            The monitored messaging regularly monitors if the connection is still available.
            It sends ping messages and receives ping messages in a defined frequency. If sending of the ping message fails
            or the ping message is not received within the specified time the connection is considered broken.<br/>
            The advantage of the monitored messaging is that the disconnection can be detected very early.<br/>
            <br/>
            When the connection is monitored, the duplex output channel periodically sends 'ping' messages
            to the duplex input channel and waits for responses.
            If the response comes within the specified timeout, the connection is open.
            <br/>
            On the receiver side, the duplex input channel waits for the 'ping' messages and monitors if the connected
            duplex output channel is still alive. If the 'ping' message does not come within the specified timeout,
            the particular duplex output channel is disconnected.
            <br/><br/>
            <b>Note</b>
            Channels created by monitored messaging factory cannot communicate with channels, that were not created
            by monitored factory. E.g. the channel created with the monitored messaging factory with underlying TCP
            will not communicate with channels created directly with TCP messaging factory. The reason is, the
            communicating channels must understand the 'ping' communication.
            <example>
            The following example shows how to use monitored messaging:
            <code>
            // Create TCP messaging.
            IMessagingSystemFactory anUnderlyingMessaging = new TcpMessagingSystemFactory();
            
            // Create monitored messaging that internally uses TCP.
            IMessagingSystemFactory aMessaging = new MonitoredMessagingSystemFactory(anUnderlyingMessaging);
            
            // Create the duplex output channel.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8045/");
            
            // Create message sender to send simple string messages.
            IDuplexStringMessagesFactory aSenderFactory = new DuplexStringMessagesFactory();
            IDuplexStringMessageSender aSender = aSenderFactory.CreateDuplexStringMessageSender();
            
            // Subscribe to receive responses.
            aSender.ResponseReceived += OnResponseReceived;
            
            // Attach output channel an be able to send messages and receive responses.
            aSender.AttachDuplexOutputChannel(anOutputChannel);
            
            ...
            
            // Send a message.
            aSender.SendMessage("Hello.");
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            It uses optimized custom serializer which is optimized to serialize/deserialize MonitorChannelMessage which is
            used for the internal communication between output and input channels.
            The ping message is sent once per second and it is expected the ping message is received at least once per two seconds.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory from specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. Websocket, TCP, ...</param>
            <param name="pingFrequency">how often the ping message is sent.</param>
            <param name="pingReceiveTimeout">the maximum time within it the ping message must be received.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the output channel which can send messages to the input channel and receive response messages.
            </summary>
            <remarks>
            In addition the output channel monitors the connection availability. It sends ping messages in a specified frequency to the input channel
            and expects receiving ping messages within a specified time.
            </remarks>
            <param name="channelId">input channel address. It must comply to underlying messaging</param>
            <returns>monitoring duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the output channel which can send messages to the input channel and receive response messages.
            </summary>
            <remarks>
            In addition the output channel monitors the connection availability. It sends ping messages in a specified frequency to the input channel
            and expects receiving ping messages within a specified time.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">response receiver id of the channel</param>
            <returns>monitoring duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the input channel which can receive messages from the output channel and send response messages.
            </summary>
            <remarks>
            In addition it expects receiving ping messages from each connected client within a specified time and sends
            ping messages to each connected client in a specified frequency.
            </remarks>
            <param name="channelId">input channel address. It must comply to underlying messaging</param>
            <returns>monitoring duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.PingFrequency">
            <summary>
            How often the ping message shall be sent.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.ReceiveTimeout">
            <summary>
            Time within it the ping message must be received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.InputChannelThreading">
            <summary>
            Sets or gets the threading mode for input channels.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.OutputChannelThreading">
            <summary>
            Sets or gets the threading mode for output channels.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.Serializer">
            <summary>
            Serializer which shall be used to serialize MonitorChannelMessage.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter">
            <summary>
            The helper allowing to observe the particular duplex output channel.
            If the channel is disconnected, it tries to reopen the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ConnectionClosed">
            <summary>
            The event is invoked when the observed duplex output channel notified, that the connection was closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ConnectionOpened">
            <summary>
            The event is invoked when the duplex output channel was reconnected.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ReconnectingFailed">
            <summary>
            The event is invoked when the reopenning of the duplex output channel failed.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel)">
            <summary>
            Constructs the reconnecter that tries to reconnect infinitely every second.
            </summary>
            <param name="duplexOutputChannel">observed duplex output channel</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel,System.TimeSpan,System.Int32)">
            <summary>
            Constructs the reconnecter from specified parameters.
            </summary>
            <param name="duplexOutputChannel">observed duplex output channel</param>
            <param name="reconnectFrequency">how often the reconnect attempt shall be performed (in case of the disconnection)</param>
            <param name="maxReconnectAttempts">max amounts of reconnect attempts. If exceeded, the ReconnectingFailed is invoked.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.EnableReconnecting">
            <summary>
            Enables the automatic reconnecting in case the disconnect is notified.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.DisableReconnecting">
            <summary>
            Disables the automatic reconnecting.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.IsReconnectingEnabled">
            <summary>
            Returns true if the reconnecting is enabled.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.NamespaceDoc">
            <summary>
            Extension for monitoring the connection.
            </summary>
            <remarks>
            The monitoring is realized by sending and receiving 'ping' messages within the specified time.
            If the sending of the 'ping' fails or the 'ping' response is not received within the specified
            time the connection is considered to be broken.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.NamespaceDoc">
            <summary>
            Extensions for messaging systems.
            </summary>
            <remarks>
            The composites are extensions which can be composed on top of each other in order to add additional features
            into the communication.
            E.g. connection monitoring, connection recovery, authentication or communication via the message bus.<br/>
            <br/>
            The following example shows how to add the connection monitoring and the authentication into the communication via TCP.
            <example>
            Example shows hot composite messaging systems can be chained to create the desired behavior.
            <code>
            // Create TCP messaging system.
            IMessagingSystemFactory anUnderlyingMessaging = new TcpMessagingSystemFactory();
            
            // Create monitored messaging which takes TCP as underlying messaging.
            IMessagingSystemFactory aMonitoredMessaging = new MonitoredMessagingFactory(anUnderlyingMessaging);
            
            // Create messaging with authenticated connection.
            // It takes monitored messaging as the underlying messaging.
            IMessagingSystemFactory aMessaging = new AuthenticatedMessagingFactory(aMonitoredMessaging, ...);
            
            // Creating channels.
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:8095/");
            IDuplexInputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8095/");
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EasyProtocolFormatter">
            <summary>
            Simple and very fast encoding/decoding for TCP, WebSocket and multicast/broadcast UDP.
            </summary>
            <remarks>
            This protocol formatter is stripped to the bare minimum. It does not encode OpenConnection and CloseConnection
            messages but it encodes only data messages.<br/>
            Therefore it can be used only with communication protocols which have own mechanisms to open and close the
            communication (TCP and WebSockets) or opening and closing the connection is not needed (multicast/broadcast UDP).<br/> 
            <br/>
            The simplicity of this formatter provides a high performance and easy portability to various platforms allowing so
            to communicate with Eneter even without having the Eneter framework.<br/>
            Here is the list of limitation when using this protocol formatter:
            <ul>
            <li>It can be used only with TCP, WebSockets or multicast/broadcast UDP.</li>
            <li>It cannot be used if automatic reconnect is needed. It means it cannot be used in buffered messaging.</li>
            </ul>
            <br/>
            Here is how this formatter encodes messages between channels:
            <b>Encoding of open connection message:</b><br/>
            N.A. - the open connection message is not used. The connection is considered open when the socket is open.<br/>
            <br/>
            <b>Encoding of close connection message:</b><br/>
            N.A. = the close connection message is not used. The connection is considered closed when the socket is closed.<br/>
            <br/>
            <b>Encoding of data message:</b><br/>
            1 byte - type of data: 10 string in UTF8, 40 bytes<br/>
            4 bytes - length: 32 bit integer indicating the size (in bytes) of message data.<br/>
            x bytes - message data<br/>
            <br/>
            The 32 bit integer indicating the length of message data is encoded as little endian byte default.
            If big endian is needed it is possible to specify it in the constructor.
            <example>
            The following example shows how to use TCP messaging with EasyProtocolFormatter:<br/>
            <code>
            // Instantiate protocol formatter.
            IProtocolFormatter aFormatter = new EasyProtocolFormatter();
            
            // Provide the protocol formatter into the messaging constructor.
            // Note: It can be only TCP or WebSocket messaging.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory(aFormatter);
            ...
            // Then use can use the messaging to create channels.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8084/");
            ...
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EasyProtocolFormatter.#ctor">
            <summary>
            Constructs the protocol formatter with default little endian encoding.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EasyProtocolFormatter.#ctor(System.Boolean)">
            <summary>
            Constructs the protocol formatter with specified endianess.
            </summary>
            <param name="isLittleEndian">true - little endian, false - big endian.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EasyProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Returns null.
            </summary>
            <remarks>
            The open connection message is not used. Therefore it returns null.
            </remarks>
            <param name="responseReceiverId">not used</param>
            <returns>null</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EasyProtocolFormatter.EncodeOpenConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Does nothing.
            </summary>
            <remarks>
            The open connection message is not used. Therefore it does not write any data to the provided output stream.
            </remarks>
            <param name="responseReceiverId">not used</param>
            <param name="outputSream">not used</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EasyProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Returns null.
            </summary>
            <remarks>
            The close connection message is not used. Therefore it returns null.
            </remarks>
            <param name="responseReceiverId">not used</param>
            <returns>null</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EasyProtocolFormatter.EncodeCloseConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Does nothing.
            </summary>
            <remarks>
            The close connection message is not used. Therefore it does not write any data to the provided output stream.
            </remarks>
            <param name="responseReceiverId">not used</param>
            <param name="outputSream">not used</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EasyProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes given message to bytes.
            </summary>
            <param name="responseReceiverId">not used</param>
            <param name="message">message serialized in string or byte[]</param>
            <returns>message encoded in byte[]</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EasyProtocolFormatter.EncodeMessage(System.String,System.Object,System.IO.Stream)">
            <summary>
            Encodes given message to bytes.
            </summary>
            <param name="responseReceiverId">not used</param>
            <param name="message">message serialized in string or byte[]</param>
            <param name="outputSream">stream into which the message will be encoded</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EasyProtocolFormatter.DecodeMessage(System.Object)">
            <summary>
            Decodes the sequence of bytes.
            </summary>
            <param name="readMessage">encoded bytes.</param>
            <returns>protocol message containing the decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EasyProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes the sequence of bytes.
            </summary>
            <param name="readStream">stream containing bytes to be decoded</param>
            <returns>protocol message containing the decoded message</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter">
            <summary>
            Default Eneter encoding/decoding.
            </summary>
            <remarks>
            Here is how this formatter encodes messages between channels:<br/>
            <br/>
            <b>Encoding of open connection message:</b><br/>
            6 bytes - header: ENETER<br/>
            1 byte  - endianess: 10 little endian, 20 big endian<br/>
            1 byte  - string encoding: 10 UTF8, 20 UTF16<br/>
            1 byte  - message type: 10 for open connection<br/>
            4 bytes - length: 32 bit integer indicating the size (in bytes) of the following string<br/>
            x bytes - responseReceiverId: client id string<br/>
            <br/>
            <b>Encoding of close connection message:</b><br/>
            6 bytes - header: ENETER<br/>
            1 byte  - endianess: 10 little endian, 20 big endian<br/>
            1 byte  - string encoding: 10 UTF8, 20 UTF16<br/>
            1 byte  - message type: 20 for close connection<br/>
            4 bytes - length: 32 bit integer indicating the size (in bytes) of the following string<br/>
            x bytes - responseReceiverId: client id string<br/>
            <br/>
            <b>Encoding of data message:</b><br/>
            6 bytes - header: ENETER<br/>
            1 byte  - endianess: 10 little endian, 20 big endian<br/>
            1 byte  - string encoding: 10 UTF8, 20 UTF16<br/>
            1 byte  - message type: 40 for data message<br/>
            4 bytes - length: 32 bit integer indicating the size (in bytes) of the following string<br/>
            x bytes - responseReceiverId: client id string<br/>
            1 byte  - message data type: 10 bytes, 20 string<br/>
            4 bytes - length: 32 bit integer indicating the size (in bytes) of the following data.<br/>
            y bytes - message data: message data
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes open connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeOpenConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes 'open connection' message directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes close connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeCloseConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes 'close connection' message directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <param name="responseReceiverId">client id</param>
            <param name="message">the serialized content of the message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeMessage(System.String,System.Object,System.IO.Stream)">
            <summary>
            Encodes 'request message' or 'response message' directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="message"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes a message or a response message from the stream.
            </summary>
            <param name="readStream">stream containing the low-level message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.DecodeMessage(System.Object)">
            <summary>
            Decodes a message or a response message from the byte[].
            </summary>
            <param name="readMessage">source of the low-level message</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter">
            <summary>
            Declares functionality to encode and decode messages used for the communication between channels.
            </summary>
            <remarks>
            The implementaton of this interface defines how 'open connection', 'close connection' and 'message data'
            messages shall be encoded and decoded during communication between channels.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes the open connection request message.
            </summary>
            <remarks>
            The message is used by the output channel to open the connection with the input channel.<br/>
            If the open connection message is not used it shall return null. 
            </remarks>
            <param name="responseReceiverId">id of the client opening the connection.</param>
            <returns>encoded open connection message.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeOpenConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes the open connection request message to the stream.
            </summary>
            <remarks>
            The message is used by the output channel to open the connection with the input channel.<br/>
            If the open connection message is not used it shall just return without writing to the stream.
            </remarks>
            <param name="responseReceiverId">id of the client opening the connection.</param>
            <param name="outputSream">output where the encoded message is written</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes the close connecion request message.
            </summary>
            <remarks>
            The message is used by the output channel to close the connection with the input channel.
            It is also used by input channel when it disconnects the output channel.<br/>
            If the close connection message is not used it shall return null.
            </remarks>
            <param name="responseReceiverId">id of the client that wants to disconnect or that will be disconnected</param>
            <returns>encoded close connection message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeCloseConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes the close connecion request message to the stream.
            </summary>
            <remarks>
            The message is used by the output channel to close the connection with the input channel.
            It is also used by input channel when it disconnects the output channel.<br/>
            If the close connection message is not used it shall just return without writing to the stream.
            </remarks>
            <param name="responseReceiverId">id of the client that wants to disconnect or that will be disconnected</param>
            <param name="outputSream">output where the encoded message is written</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes the data message.
            </summary>
            <remarks>
            The message is used by the output as well as input channel to send the data message.
            </remarks>
            <param name="responseReceiverId">client id. It is empty string in case of output channel.</param>
            <param name="message">message serialized message to be sent.</param>
            <returns>encoded data message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeMessage(System.String,System.Object,System.IO.Stream)">
            <summary>
            Encodes the data message into the stream.
            </summary>
            <remarks>
            The message is used by the output as well as input channel to send the data message.
            </remarks>
            <param name="responseReceiverId">id of the client that wants to send the message. It is empty string if the response message is sent.</param>
            <param name="message">serialized message to be sent.</param>
            <param name="outputSream">output where the encoded message is written</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes message from the stream.
            </summary>
            <param name="readStream">stream to be read</param>
            <returns>decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.DecodeMessage(System.Object)">
            <summary>
            Decodes message from the given object.
            </summary>
            <param name="readMessage">reference to the object.</param>
            <returns>decoded message</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType">
            <summary>
            Type of the message sent between channels.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.OpenConnectionRequest">
            <summary>
            Open connection message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.CloseConnectionRequest">
            <summary>
            Close connection message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.MessageReceived">
            <summary>
            Request message or response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage">
            <summary>
            Message decoded by the protocol formatter.
            </summary>
            <remarks>
            The protocol formatter is used for the internal communication between output and input channel.
            When the channel receives a message it uses the protocol formatter to figure out if is is 'Open Connection',
            'Close Connection' or 'Data Message'.<br/>
            Protocol formatter decodes the message and returns ProtocolMessage.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType,System.String,System.Object)">
            <summary>
            Constructs the protocol message from the given parameters.
            </summary>
            <param name="messageType">type of the message</param>
            <param name="responseReceiverId">client id</param>
            <param name="message">message content</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.MessageType">
            <summary>
            Type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.ResponseReceiverId">
            <summary>
            Client id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.Message">
            <summary>
            If message type is MessageReceived the it contains the serialized message data.
            Otherwise it is null.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.NamespaceDoc">
            <summary>
            Encoding/decoding the communication between output and input channels.
            </summary>
            <remarks>
            The protocol formatter encodes low-level messages sent between output and input channels.
            The output channel can send following messages to the input channel:
            <ul>
            <li><b>Open Connection</b> - Output channel sends this message to the input channel when it opens the connection.</li>
            <li><b>Close Connection</b> - Output channel sends this message to the input channel when it closes the connection.</li>
            <li><b>Message</b> - output channel uses this message when it sends a data message to the input channel.</li>
            </ul>
            The input channel can send following messages to the input channel:
            <ul>
            <li><b>Close Connection</b> - The input channel sends this message to the output channel when it disconnects the output channel. </li>
            <li><b>Message</b> - The input channel sends this message when it sends a data message to the output channel.</li>
            </ul>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpListenerContextExt">
            <summary>
            Extends HttpListenerContext by helper methods.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpListenerContextExt.GetRequestMessageStr(System.Net.HttpListenerContext)">
            <summary>
            Gets all request message data in string.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpListenerContextExt.GetRequestMessage(System.Net.HttpListenerContext)">
            <summary>
            Gets the all request message data in bytes.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpListenerContextExt.SendResponseMessage(System.Net.HttpListenerContext,System.Byte[])">
            <summary>
            Sends the response message.
            </summary>
            <param name="context"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpListenerContextExt.SendResponseMessage(System.Net.HttpListenerContext,System.String)">
            <summary>
            Sends the response message.
            </summary>
            <param name="context"></param>
            <param name="message"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory">
            <summary>
            Messaging system delivering messages via HTTP.
            </summary>
            <remarks>
            It creates the communication channels using HTTP for sending and receiving messages.
            The channel id must be a valid URI address. E.g.: http://127.0.0.1/something/ or https://127.0.0.1/something/. <br/>
            Because HTTP is request-response based protocol, it does not keep the connection open.
            Therefore, for the bidirectional communication used by duplex channels, the polling mechanism is used.
            The duplex output channel regularly polls for response messages and the duplex input channel constantly measures the inactivity time
            to recognize whether the duplex output channel is still connected.<br/><br/>
            Notice, to start listening via input channel (or duplex input channel), the application must be executed with sufficient rights.
            Otherwise the exception will be thrown.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory that will create channels with default settings. The polling
            frequency will be 500 ms and the inactivity timeout will be 10 minutes.
            </summary>
            <remarks>
            The polling frequency and the inactivity time are used only by duplex channels.
            The polling frequency specifies how often the duplex output channel checks if there are pending response messages.
            The inactivity time is measured by the duplex input channel and specifies the maximum time, the duplex output channel
            does not have to poll for messages.
            If the inactivity time is exceeded, considers the duplex output channel as disconnected.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs the factory that will create channel with specified settings.
            </summary>
            <remarks>
            The polling frequency and the inactivity time are used only by duplex channels.
            The polling frequency specifies how often the duplex output channel checks if there are pending response messages.
            The inactivity time is measured by the duplex input channel and specifies the maximum time, the duplex output channel
            does not have to poll for messages.
            If the inactivity time is exceeded, considers the duplex output channel as disconnected.
            </remarks>
            <param name="pollingFrequency">how often the duplex output channel polls for the pending response messages</param>
            <param name="inactivityTimeout">maximum time (measured by duplex input channel), the duplex output channel does not have to poll
            for response messages. If the time is exceeded, the duplex output channel is considered as disconnected.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32,System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the factory that will create channel with specified settings.
            </summary>
            <remarks>
            The polling frequency and the inactivity time are used only by duplex channels.
            The polling frequency specifies how often the duplex output channel checks if there are pending response messages.
            The inactivity time is measured by the duplex input channel and specifies the maximum time, the duplex output channel
            does not have to poll for messages.
            If the inactivity time is exceeded, considers the duplex output channel as disconnected.
            </remarks>
            <param name="pollingFrequency">how often the duplex output channel polls for the pending response messages</param>
            <param name="inactivityTimeout">maximum time (measured by duplex input channel), the duplex output channel does not have to poll
            for response messages. If the time is exceeded, the duplex output channel is considered as disconnected.</param>
            <param name="protocolFormatter">formatter for low-level messages between duplex output channel and duplex input channel</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates duplex output channel which can send and receive messages from the duplex input channel using HTTP.
            </summary>
            <remarks>
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid address of the receiver. e.g. 127.0.0.1:8090</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates duplex output channel which can send and receive messages from the duplex input channel using HTTP.
            </summary>
            <remarks>
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            </remarks>
            <param name="channelId">Identifies the input channel which shall be connected. The channel id must be a valid URI address e.g. http://127.0.0.1:8090/</param>
            <param name="responseReceiverId">Unique identifier of the output channel. If null then the id is generated automatically.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel which can receive and send messages to the duplex output channel using UDP.
            </summary>
            <remarks>
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            </remarks>
            <param name="channelId">channel id specifying the address the duplex input channel listens to.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.InputChannelThreading">
            <summary>
            Sets or gets the threading mode for input channels.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Sets or gets the threading mode for output channels.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.myPollingFrequency">
            <summary>
            Defines how often the client poll the server for response messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebClient">
            <summary>
            HTTP client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebClient.Get(System.Uri)">
            <summary>
            Sends the GET request to the HTTP server.
            </summary>
            <param name="uri">The address including the input parameters.</param>
            <returns>Response from the HTTP server.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebClient.Post(System.Uri,System.String)">
            <summary>
            Sends the POST request to the HTTP server.
            </summary>
            <param name="uri">The address including the input parameters.</param>
            <param name="body">Data for the post request.</param>
            <returns>Response from the HTTP server.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebClient.Post(System.Uri,System.Byte[])">
            <summary>
            Sends the POST request to the HTTP server.
            </summary>
            <param name="uri">The address including the input parameters.</param>
            <param name="body">Data for the post request.</param>
            <returns>Response from the HTTP server.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebClient.Put(System.Uri,System.String)">
            <summary>
            Sends the PUT request to the HTTP server.
            </summary>
            <param name="uri">The address including the input parameters.</param>
            <param name="body">Data for the put request.</param>
            <returns>Response from the HTTP server.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebClient.Put(System.Uri,System.Byte[])">
            <summary>
            Sends the PUT request to the HTTP server.
            </summary>
            <param name="uri">The address including the input parameters.</param>
            <param name="body">Data for the put request.</param>
            <returns>Response from the HTTP server.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebClient.Patch(System.Uri,System.String)">
            <summary>
            Sends the PATCH request to the HTTP server.
            </summary>
            <param name="uri">The address including the input parameters.</param>
            <param name="body">Data for the patch request.</param>
            <returns>Response from the HTTP server.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebClient.Patch(System.Uri,System.Byte[])">
            <summary>
            Sends the PATCH request to the HTTP server.
            </summary>
            <param name="uri">The address including the input parameters.</param>
            <param name="body">Data for the patch request.</param>
            <returns>Response from the HTTP server.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebClient.Delete(System.Uri)">
            <summary>
            Sends the DELETE request to the HTTP server.
            </summary>
            <param name="uri">The address including the input parameters.</param>
            <returns>Response from the HTTP server.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebClient.Request(System.String,System.Uri,System.String)">
            <summary>
            Sends a request to the HTTP server.
            </summary>
            <param name="httpMethod">HTTP method specifying the request.</param>
            <param name="uri">The address including the input parameters.</param>
            <param name="body">The request data.</param>
            <returns>Response from the HTTP server.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebClient.Request(System.String,System.Uri,System.Byte[])">
            <summary>
            Sends a request to the HTTP server.
            </summary>
            <param name="httpMethod">HTTP method specifying the request.</param>
            <param name="uri">The address including the input parameters.</param>
            <param name="body">The request data.</param>
            <returns>Response from the HTTP server.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebResponseExt">
            <summary>
            Extension methods for HttpWebResponse.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebResponseExt.GetResponseMessageStr(System.Net.HttpWebResponse)">
            <summary>
            Returns the whole response message in string.
            </summary>
            <param name="httpResponse"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebResponseExt.GetResponseMessage(System.Net.HttpWebResponse)">
            <summary>
            Returns the whole response message in bytes.
            </summary>
            <param name="httpResponse">A response received from the HTTP server.</param>
            <returns>The response message in bytes.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebServer">
            <summary>
            HTTP server.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebServer.#ctor(System.String)">
            <summary>
            Constructs the HTTP server.
            </summary>
            <param name="absoluteUri">The root HTTP address to be listened.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebServer.HttpListenerFactory">
            <summary>
            Allows to set the custom factory method for the underlying HttpListner.
            </summary>
            <remarks>
            If it is null then HttpListener is created by a default way.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebServer.StartListening(System.Action{System.Net.HttpListenerContext})">
            <summary>
            Starts the listening.
            </summary>
            <param name="connectionHandler">Callback to be called when a request is received.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebServer.StopListening">
            <summary>
            Stops the listening.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebServer.IsListening">
            <summary>
            Returns true if the listening is active.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebServer.DoListening">
            <summary>
            Loop for the main listening thread.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpWebServer.CreateHttpListener">
            <summary>
            Default factory method for HttpListener.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.NamespaceDoc">
            <summary>
            Communication via HTTP.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs">
            <summary>
            Event argument containing parameters of the communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the event argument.
            </summary>
            <param name="channelId">Identifies the receiver of request messages. (e.g. tcp://127.0.0.1:8090/)</param>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.ChannelId">
            <summary>
            Returns the channel id identifying the receiver of request messages. (e.g. tcp://127.0.0.1:8090/).
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.ResponseReceiverId">
            <summary>
            Returns the unique logical id identifying the receiver of response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs">
            <summary>
            Event argument used to notify that duplex input channel received a message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.#ctor(System.String,System.Object,System.String,System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="channelId">Identifies the receiver of request messages. (e.g. tcp://127.0.0.1:8090/)</param>
            <param name="message">message</param>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel">
            <summary>
            Duplex input channel which can receive messages from the duplex output channel and send response messages.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverConnected">
            <summary>
            The event is raised when an output channel opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected">
            <summary>
            The event is raised when an output channel closed the connection.
            </summary>
            <remarks>
            The event is not raised when the connection was closed by the input channel.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.MessageReceived">
            <summary>
            The event is raised when a message was received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ChannelId">
            <summary>
            Returns address of this duplex input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StartListening">
            <summary>
            Starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StopListening">
            <summary>
            Stops listening to messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.IsListening">
            <summary>
            Returns true if the duplex input channel is listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.SendResponseMessage(System.String,System.Object)">
            <summary>
            Sends a message to a connected output channel.
            </summary>
            <param name="responseReceiverId">Identifies the connected output channel to which the message shall be sent.
            If the value is * then the input channel sends the message to all connected output channels.
            <example>
            Sends message to all connected output channels.
            <code>
            anInputChannel.SendResponseMessage("*", "Hello");
            </code>
            </example>
            </param>
            <param name="message">response message</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.DisconnectResponseReceiver(System.String)">
            <summary>
            Disconnects the output channel.
            </summary>
            <param name="responseReceiverId">Identifies output channel which shall be disconnected.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.Dispatcher">
            <summary>
            Returns dispatcher that defines the threading model for raising events.
            </summary>
            <remarks>
            Dispatcher is responsible for raising ResponseReceiverConnected, ResponseReceiverDisconnected and MessageReceived events
            according to desired thread model.
            E.g. events are queued and raised by one particular thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel">
            <summary>
            Duplex output channel which can send messages to the duplex input channel and receive response messages.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionOpened">
            <summary>
            The event is raised when the connection with the duplex input channel was opened.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed">
            <summary>
            The event is raised when the connection was closed from the input channel or the it was closed due to a broken connection.
            </summary>
            <remarks>
            The event is not raised if the connection was closed by the output channel by calling CloseConnection().
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseMessageReceived">
            <summary>
            The event is raised when a response message was received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ChannelId">
            <summary>
            Returns the address of the input channel.
            </summary>
            <remarks>
            The channel id represents the communication address. The syntax of the channel id depends on the chosen
            communication. If the messaging is based on http, the address would be e.g.: http://127.0.0.1/Something/ or
            http://127.0.0.1:7345/Something/. If the communication is based on tcp, the address would be e.g.: tcp://127.0.0.1:7435/.
            For the named pipe, e.g. net.pipe://127.0.0.1/SomePipeName/.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseReceiverId">
            <summary>
            Returns the unique identifier of this output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message to the input channel.
            </summary>
            <param name="message">message to be sent. It can be String or byte[] or some other type depending on used protocol formatter.</param>
            <exception cref="T:System.InvalidOperationException">If the connection is not open.</exception>
            <exception cref="T:System.Exception">Any exception thrown during sending of a message. E.g. if sending via TCP fails.</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.OpenConnection">
            <summary>
            Opens the connection with the duplex input channel.
            </summary>
            <exception cref="T:System.InvalidOperationException">If the connection is already open.</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.CloseConnection">
            <summary>
            Closes the connection with the duplex input channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.IsConnected">
            <summary>
            Returns true if the duplex output channel is connected to the duplex input channel and listens to response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.Dispatcher">
            <summary>
            Returns dispatcher that defines the threading model for raising events.
            </summary>
            <remarks>
            Dispatcher is responsible for raising ConnectionOpened, ConnectionClosed and ResponseMessageReceived events
            according to desired thread model.
            E.g. events are queued and raised by one particular thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory">
            <summary>
            Represents messaging providing output and input channels for the communication.
            </summary>
            <remarks>
            This factory interface is supposed to be implemented by all messaging systems.
            Particular messaging systems are then supposed to provide correct implementations for output and input channels
            using their transportation mechanisms. E.g. for TCP, Websockets, ... . 
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the output channel which can sends and receive messages from the input channel.
            </summary>
            <param name="channelId">address of the input channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the output channel which can sends and receive messages from the input channel.
            </summary>
            <param name="channelId">address of the input channel</param>
            <param name="responseReceiverId">unique identifier of this duplex output channel. If the value is null then
            the identifier is genearated automatically</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the input channel which can receive and send messages to the output channel.
            </summary>
            <param name="channelId">address on which the duplex input channel shall listen</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs">
            <summary>
            Event argument representing the response receiver on the service site.
            </summary>
            <remarks>
            This event argument is typically used e.g. when the client opened/closed connection. 
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event argument.
            </summary>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.ResponseReceiverId">
            <summary>
            Returns the unique logical id identifying the receiver of response messages.
            </summary>
            <remarks>
            This id identifies who receives the response message on the client side.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.NamespaceDoc">
            <summary>
            Messaging system interfaces.
            </summary>
            <remarks>
            The messaging system is responsible for transferring messages via channels.<br/>
            The input channel represents the service which is identified by its address.
            It can accept connections from multiple output channels and receive/send messages from/to connected output channels.<br/>
            The output channel represents the client side. It can connect the input channel (by specifying the address).
            Then it can send/receive messages to/from the connected input channel.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.StartListening(System.Action{System.IO.Stream})">
            <summary>
            Starts the thread where the instance loops trying to serve client requests.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.SetStopListeningFlag">
            <summary>
            Sets the stop listening flag before call StopListening().
            The problem is that the StopListening() stops some listening instance - not neccessarily this one.
            Therefore, we let know to all of them that the sop will come.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.StopListening(System.String,System.Collections.Generic.List{Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance})">
            <summary>
            Stops listening of one instance listening to this pipe.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.DoListening">
            <summary>
            Listens to client requests and put them to the queue from where the working thread takes them
            and notifies the call-backs the pipe input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory">
            <summary>
            Messaging system delivering messages via named pipes.
            </summary>
            <remarks>
            It creates the communication channels for sending and receiving messages using Named Pipes.
            The channel id must be a valid URI address. E.g.: net.pipe//127.0.0.1/SomeName/ .
            <br/><br/>
            The input channel creates the pipe for the reading and waits for connections. To handle more connections
            in parallel there are more threads serving them (by default 10 threads). Every such thread waits
            for messages and puts them to the message queue. The message queue is connected to one working thread
            that removes messages one by one and notifies subscribers of the input channel.
            Therefore the subscribers are notified always from the same working thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The default parameters are: 10 serving threads, 10 seconds for connection timeout.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs the factory specifying the number of processing threads in the input channel and the timeout
            for the output channel.
            </summary>
            <param name="numberOfInputchannelListeningThreads">
            Number of threads that will listen in parallel in input channels created by the factory.
            The maximum number is 254. Many threads can increase the number of processing connections at the same time
            but it consumes a lot of resources.
            </param>
            <param name="pipeConnectionTimeout">
            The maximum time in miliseconds, the output channel waits to connect the pipe and sends the message.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor(System.Int32,System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the factory specifying the number of processing threads in the input channel and the timeout
            for the output channel. It also allows to specify the security settings for the pipe.
            </summary>
            <remarks>
            Security settings can be needed, if communicating processes run under different integrity levels.
            E.g. If the service runs under administrator account and the client under some user account,
            then the communication will not work until the pipe security is not set.
            (Client will get access denied exception.)
            <example>
            The following example shows how to set the pipe security on the service running under administrator
            account to be accessible from client processes.
            <code>
            PipeSecurity aPipeSecurity = new PipeSecurity();
            
            // Set to low integrity level.
            aPipeSecurity.SetSecurityDescriptorSddlForm("S:(ML;;NW;;;LW)");
            
            SecurityIdentifier aSid = new SecurityIdentifier(WellKnownSidType.WorldSid, null);
            ipeAccessRule aPipeAccessRule = new PipeAccessRule(aSid, PipeAccessRights.ReadWrite, AccessControlType.Allow);
            aPipeSecurity.AddAccessRule(aPipeAccessRule);
            
            // Create the messaging communicating via Named Pipes.
            IMessagingSystemFactory aMessagingSystem = new NamedPipeMessagingSystemFactory(10, 10000, aPipeSecurity);
            </code>
            </example>
            </remarks>
            <param name="numberOfInputchannelListeningThreads">
            Number of threads that will listen in parallel in input channels created by the factory.
            The maximum number is 254. Many threads can increase the number of processing connections at the same time
            but it consumes a lot of resources.
            </param>
            <param name="pipeConnectionTimeout">
            The maximum time in miliseconds, the output channel waits to connect the pipe and sends the message.</param>
            <param name="protocolFormatter">formatter of low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor(System.Int32,System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter,System.IO.Pipes.PipeSecurity)">
            <summary>
            Constructs the factory specifying the number of processing threads in the input channel and the timeout
            for the output channel. It also allows to specify the security settings for the pipe.
            </summary>
            <remarks>
            Security settings can be needed, if communicating processes run under different integrity levels.
            E.g. If the service runs under administrator account and the client under some user account,
            then the communication will not work until the pipe security is not set.
            (Client will get access denied exception.)
            <example>
            The following example shows how to set the pipe security on the service running under administrator
            account to be accessible from client processes.
            <code>
            PipeSecurity aPipeSecurity = new PipeSecurity();
            
            // Set to low integrity level.
            aPipeSecurity.SetSecurityDescriptorSddlForm("S:(ML;;NW;;;LW)");
            
            SecurityIdentifier aSid = new SecurityIdentifier(WellKnownSidType.WorldSid, null);
            ipeAccessRule aPipeAccessRule = new PipeAccessRule(aSid, PipeAccessRights.ReadWrite, AccessControlType.Allow);
            aPipeSecurity.AddAccessRule(aPipeAccessRule);
            
            // Create the messaging communicating via Named Pipes.
            IMessagingSystemFactory aMessagingSystem = new NamedPipeMessagingSystemFactory(10, 10000, aPipeSecurity);
            </code>
            </example>
            </remarks>
            <param name="numberOfPipeInstances">
            Number of clients that can be connected at the same time.
            The maximum number is 254. Many threads can increase the number of processing connections at the same time
            but it consumes a lot of resources.
            </param>
            <param name="pipeConnectionTimeout">
            The maximum time in miliseconds, the output channel waits to connect the pipe and sends the message.</param>
            <param name="protocolFormatter">formatter of low-level messages between channels</param>
            <param name="pipeSecurity">
            Pipe security.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates duplex output channel which can send and receive messages from the duplex input channel using Named Pipes.
            </summary>
            <param name="channelId">Identifies the input channel which shall be connected. The channel id must be a valid URI address e.g. net.pipe://127.0.0.1/SomeName/ </param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
             Creates duplex output channel which can send and receive messages from the duplex input channel using Named Pipes.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the input channel which shall be connected. The channel id must be a valid URI address e.g. net.pipe://127.0.0.1/SomeName/ </param>
            <param name="responseReceiverId">Unique identifier of the output channel. If null then the id is generated automatically.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel which can receive and send messages to the duplex output channel using Named Pipe.
            </summary>
            <param name="channelId">Named pipe address which shall be used for the listening. E.g. net.pipe//127.0.0.1/SomeName/ </param>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.InputChannelThreading">
            <summary>
            Sets or gets the threading mode for input channels.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Sets or gets the threading mode for output channels.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamespaceDoc">
            <summary>
            Communication via Named Pipes.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.DefaultMessagingSystemFactory.InputChannelThreading">
            <summary>
            Sets/gets threading mode for input channels.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.DefaultMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Sets/gets threading mode used for input channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector">
            <summary>
            Declares the input connector which provides a basic low-level listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector.StartListening(System.Action{Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.MessageContext})">
            <summary>
            Starts listening to messages.
            </summary>
            <param name="messageHandler">handler processing incoming messages. If it returns true the connection stays
            open and listener can loop for a next messages. If it returns false the listener shall not loop for the
            next message.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector.StopListening">
            <summary>
            Stops listening to messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector.IsListening">
            <summary>
            Returns true if the listening is running.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider">
            <summary>
            The interface declares the default functionality to send and receive messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.SendMessage(System.String,System.Object)">
            <summary>
            Sends the message to desired receiver.
            </summary>
            <param name="receiverId"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.RegisterMessageHandler(System.String,System.Action{System.Object})">
            <summary>
            Registers the method handling the message.
            </summary>
            <param name="receiverId"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.UnregisterMessageHandler(System.String)">
            <summary>
            Unregisters the handler.
            </summary>
            <param name="receiverId"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IOutputConnector">
            <summary>
            Declares the output connector which provides a basic low-level functionality to open connection and send messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory">
            <summary>
            Messaging system delivering messages synchronously within the calling thread (like a method call).
            </summary>
            <remarks>
            It creates output and input channels using the caller thread to deliver messages.
            It means e.g. if the output channel calls sendMessage(...) then when the input channel receives the message
            in the same thread.   
            <br/><br/>
            Different instances of SynchronousMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message through this messaging system
            then output and input channels must be created with the same instance of SynchronousMessagingSystemFactory.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <remarks>
            Note: Every instance of the synchronous messaging system factory represents one messaging system.
                  It means that two instances of this factory class creates channels for two independent messaging system.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <param name="protocolFormatter">formatter used to encode low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel communicating with the specified duplex input channel using synchronous local call.
            </summary>
            <remarks>
            The duplex output channel can send messages and receive response messages.
            </remarks>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel communicating with the specified duplex input channel using synchronous local call.
            </summary>
            <remarks>
            The duplex output channel can send messages and receive response messages.
            </remarks>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <param name="responseReceiverId">identifies the response receiver of this duplex output channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel listening to messages on the specified channel id.
            </summary>
            <remarks>
            The duplex input channel can send response messages back to the duplex output channel.
            </remarks>
            <param name="channelId">identifies this duplex input channel</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.NamespaceDoc">
            <summary>
            Synchronous communication within one process (like a synchronous local call).
            </summary>
            <remarks>
            This messaging system transfers messages synchronously in the context of the calling thread.
            Therefore the calling thread is blocked until the message is delivered and processed.
            The messaging system is very fast and is suitable to deliver messages between components
            within one process.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.HostListenerBase">
            <summary>
            Base class representing listeners listening to the particular IP address and port and
            forwarding the processing according to path to the correct handler.
            E.g. http://127.0.0.1:9055/aaa/bbb/.
            The Host listener is listening to 127.0.0.1:9055. Then it parse out the path /aaa/bbb/ and
            forwards the request to the handler responsible for this path.
            </summary>
            <remarks>
            This is used for the implementation of http and websocket listeners.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.HostListenerController">
            <summary>
            Single static class ensuring it is possible to register more listeners using same IP address and port
            but different paths.
            </summary>
            <remarks>
            E.g.: The user code wants to listen to these 3 addresses:
            http://127.0.0.1:9055/aaa/bbb/
            http://127.0.0.1:9055/aaa/ccc/
            http://127.0.0.1:9055/aaa/ddd/
            
            All addresses share the same IP address and port. They are different only in paths.
            This class is responsible for maintaining listeners to IP address and port.
            So that if the user code wants to register next listener it checks if there is a listener to IP address and port.
            If yes, then it registers just the new path.
            If not, then it creates the listener to the IP address and port and register there the path.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.HostListenerController.StartListening(System.Uri,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.IHostListenerFactory,System.Object,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory)">
            <summary>
            Starts listening for the given URI path.
            </summary>
            <remarks>
            The listening consists of two parts:
            => Host listener - TCP listening on an address and port.
            => Path listener - based on the above protocol (HTTP or WebSocket) listening to the path.
            
            If the URI contains hostname instead of the IP address then it resolves the host name.
            But the result can be multiple addresses. E.g. for localhost it can return IPV4: 127.0.0.1 and IPV6: [::1].
            In sach case it will try to start listening to all addresses associated with the host name.
            If start listening fails for one of those addresses then StartListening throws exception.
            
            </remarks>
            <param name="address"></param>
            <param name="hostListenerFactory"></param>
            <param name="connectionHandler"></param>
            <param name="serverSecurityFactory"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.HostListenerController.IsListening(System.Uri)">
            <summary>
            Returns true if somebody is listening to the given uri.
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.IHostListenerFactory">
            <summary>
            Instantiates the host listener for the given IP address and port.
            </summary>
            <remarks>
            The host listener then processes the TCP connection and parses out the path.
            Then it forwards the message to the correct path listener.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.IHostListenerFactory.ListenerType">
            <summary>
            Returns the type of the of the host listener. The host listener is derived from HostListenerBase.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.IHostListenerFactory.CreateHostListener(System.Net.IPEndPoint,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory)">
            <summary>
            Creates the host listener.
            </summary>
            <param name="address"></param>
            <param name="securityFactory"></param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.PathListenerProviderBase`1">
            <summary>
            Base class representing listeners listening on IP address, port and path.
            E.g. websockets and http
            </summary>
            <typeparam name="_TClientContext"></typeparam>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory">
            <summary>
            The factory class creating the security stream allowing the authentication and encrypted communication
            based on 'Negotiate communication protocol'.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory.#ctor">
            <summary>
            Constructs the factory that will use client's default credentials and the service principal name will not be specified.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory.#ctor(System.Net.NetworkCredential,System.String)">
            <summary>
            Constructs the factory that will use the specified user credentials and specified service principal name.
            </summary>
            <param name="networkCredential">identity of the client</param>
            <param name="servicePrincipalName">service principal name that uniquely identifies the server to authenticate</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates security stream and authenticates as client.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type NegotiateStream.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory">
            <summary>
            The factory class creating the security stream allowing authentication as client and encrypted communication
            based on SSL protocol.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.#ctor(System.String)">
            <summary>
            Constructs the factory for the case where only the server identity is verifyied.
            </summary>
            <param name="hostName">The host the client wants to communicate with. The host name must match with the certificate name.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.#ctor(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection)">
            <summary>
            Constructs the factory for the case where server identity and also the client identity are verifyied.
            </summary>
            <param name="hostName">The host the client wants to communicate with. The host name must match with the certificate name.</param>
            <param name="clientCertificates">List of certificates provided by the client. If null, the client is not verified.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.#ctor(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <summary>
            Constructs the factory for the case where server identity and also the client identity can be verifyied.
            </summary>
            <param name="hostName">The host the client wants to communicate with. The host name must match with the certificate name.</param>
            <param name="certificates">List of certificates provided by the client. If null, the client is not verified.</param>
            <param name="userCertificateValidationCallback">User provided delegate for validating the certificate supplied by the remote party.</param>
            <param name="userCertificateSelectionCallback">User provided delegate for selecting the certificate used for authentication.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.AcceptedProtocols">
            <summary>
            Sets or gets accepted versions of SSL/TLS protocols.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates the security stream and performs the authentication as client.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type SslStream.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory">
            <summary>
            Creates the network stream.
            </summary>
            <remarks>
            The security stream wrapps the source stream and provides functionality for authentication (verifying communicating parts),
            encryption (writes encrypted data to the wrapped stream) and decryption (decrypts data from the wrapped stream).
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates the security stream and performs the authentication.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerNegotiateFactory">
            <summary>
            The factory class creating the security stream allowing authentication as server and encrypted communication
            based on 'Negotiate communication protocol'.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerNegotiateFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates security stream and authenticates as server.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type NegotiateStream.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory">
            <summary>
            The factory class creating the security stream allowing authentication as server and encrypted communication
            based on SSL protocol.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="certificate">Server certificate.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="certificate">Server certificate.</param>
            <param name="isClientCertificateRequired">true - if the client identity is verified too.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="certificate">Server certificate.</param>
            <param name="isClientCertificateRequired">true - if the client identity is verified too.</param>
            <param name="userCertificateValidationCallback">User provided delegate for validating the certificate supplied by the remote party.</param>
            <param name="userCertificateSelectionCallback">User provided delegate for selecting the certificate used for authentication.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.AcceptedProtocols">
            <summary>
            Sets or gets accepted versions of SSL/TLS protocols.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates the security stream and performs the authentication as client.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type SslStream.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.NamespaceDoc">
            <summary>
            Security for TCP communication.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory">
            <summary>
            Messaging system delivering messages via TCP.
            </summary>
            <remarks>
            It creates the communication channels using TCP for sending and receiving messages.
            The channel id must be a valid URI address. E.g.: tcp://127.0.0.1:6080/.
            <example>
            Creating output and input channel for TCP messaging.
            <code>
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            
            // Create duplex input channel which can receive messages on the address 127.0.0.1 and the port 9043
            // and which can send response messages to connected output channels.
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:9043/");
            
            // Subscribe to handle messages.
            anInputChannel.MessageReceived += OnMessageReceived;
            
            // Start listening and be able to receive messages.
            anInputChannel.StartListening();
            
            ...
            
            // Stop listening.
            anInputChannel.StopListeing();
            </code>
            
            <code>
            // Create duplex output channel which can send messages to 127.0.0.1 on the port 9043 and
            // receive response messages.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:9043/");
            
            // Subscribe to handle messages.
            anOutputChannel.ResponseMessageReceived += OnMessageReceived;
            
            // Open connection to the input channel which listens to tcp://127.0.0.1:9043/.
            anOutputChannel.OpenConnection();
            
            ...
            
            // Close connection.
            anOutputChannel.CloseConnection();
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the TCP messaging factory.
            </summary>
            <remarks>
            The connection and sending timeouts are sent to 30 seconds. All incoming messages will notified via one working thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the TCP messaging factory.
            </summary>
            <param name="protocolFormatter">formats OpenConnection, CloseConnection and Message messages between channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates duplex output channel which can send and receive messages from the duplex input channel using TCP.
            </summary>
            <remarks>
            <example>
            Creating the duplex output channel.
            <code>
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8765/");
            </code>
            </example>
            </remarks>
            <param name="channelId">Identifies the input channel which shall be connected. The channel id must be a valid URI address e.g. tcp://127.0.0.1:8090/ </param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates duplex output channel which can send and receive messages from the duplex input channel using TCP.
            </summary>
            <remarks>
            <example>
            Creating the duplex output channel with specified client id.
            <code>
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8765/", "MyUniqueClientId_1");
            </code>
            </example>
            </remarks>
            <param name="channelId">Identifies the input channel which shall be connected. The channel id must be a valid URI address e.g. tcp://127.0.0.1:8090/</param>
            <param name="responseReceiverId">Unique identifier of the output channel. If null then the id is generated automatically.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel which can receive and send messages to the duplex output channel using TCP.
            </summary>
            <remarks>
            <example>
            Creating duplex input channel.
            <code>
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:9876/");
            </code>
            </example>
            </remarks>
            <param name="channelId">The IP address and port which shall be used for listening.
            The channel id must be a valid URI address (e.g. tcp://127.0.0.1:8090/).<br/>
            If the IP address is 0.0.0.0 then it will listen to all available IP addresses.
            E.g. if the address is tcp://0.0.0.0:8033/ then it will listen to all available IP addresses on the port 8033.
            </param>
            <returns>duplex input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.GetAvailableIpAddresses">
            <summary>
            Returns IP addresses assigned to the device which can be used for the listening.
            </summary>
            <returns>array of available addresses</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.IsPortAvailableForTcpListening(System.String)">
            <summary>
            Checks if the port is available for TCP listening.
            </summary>
            <remarks>
            The method checks if the IP address and the port is available for TCP listenig.
            </remarks>
            <param name="ipAddressAndPort">IP address and port.</param>
            <example>
            Check if the application can start listening on the IP address 127.0.0.1 and the port 8099.
            <code>
            bool isPortAvailable = TcpMessagingSystemFactory.IsPortAvailableForTcpListening("tcp://127.0.0.1:8099/");
            </code>
            </example>
            <returns>true if the port is available</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ServerSecurityStreamFactory">
            <summary>
            Sets or gets the security stream factory for the server.
            If the factory is set, then the input channel and the duplex input channel use it to establish
            the secure communication.
            </summary>
            <remarks>
            If set to null then default NonSecurityFactory is created and used.
            <example>
            Using SSL on the service side.
            <code>
            TcpMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            aMessaging.ServerSecurityStreamFactory = new ServerSslFactory(serverX509Certificate);
            
            // Create input channel using SSL.
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:9876/");
            </code>
            </example>
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ClientSecurityStreamFactory">
            <summary>
            Sets and gets the security stream factory for the client.
            If the factory is set, then the output channel and the duplex output channel use it to establish
            the secure communication.
            </summary>
            <remarks>
            If set to null then default NonSecurityFactory is created and used.
            <example>
            Using SSL on the client side.
            <code>
            TcpMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            aMessaging.ClientSecurityStreamFactory = new ClientSslFactory(hostNamePresentOnServiceCertificate);
            
            // Create input channel using SSL.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:9876/");
            </code>
            </example>
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ResponseReceiverPort">
            <summary>
            Sets or gets the port which shall be used for receiving response messages in output channels.
            </summary>
            <remarks>
            When a client connects an IP address and port a random free port is assigned for receiving messages.
            This property allows to use a specific port instead of random one.<br/>
            <br/>
            Default value is -1 which means a random free port is chosen for receiving response messages.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.SendBufferSize">
            <summary>
            Size of the buffer in bytes for sending messages. Default value is 8192 bytes.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ReceiveBufferSize">
            <summary>
            Size of the buffer in bytes for receiving messages. Default value is 8192 bytes.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.SendTimeout">
            <summary>
            Sets or gets timeout to send a message. Default is 0 what is infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ReceiveTimeout">
            <summary>
            Sets or gets timeout to receive a message. If not received within the time the connection is closed. Default is 0 what it infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ReuseAddress">
            <summary>
            Sets or gets the flag indicating whether the socket can be bound to the address which is already in use.
            </summary>
            <remarks>
            If the value is true then the input channels or output channels can start listening to the IP address and port which is already used by other channel.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ConnectTimeout">
            <summary>
            Sets ot gets timeout to open the connection. Default is 30000 miliseconds. Value 0 is infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.MaxAmountOfConnections">
            <summary>
            Sets or gets the maximum amount of connections the input channel can accept.
            </summary>
            <remarks>
            The default value is -1 which means the amount of connections is not restricted.<br/>
            If the maximum amount of connections is reached and some other client opens the TCP connection its
            socket is automatically closed.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.InputChannelThreading">
            <summary>
            Sets or gets the threading mode for input channels.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed one by one via a working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Sets or gets the threading mode for output channels.
            </summary>
            <remarks>
            Default setting is that received response messages are routed one by one via a working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.NamespaceDoc">
            <summary>
            Communication via TCP.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory">
            <summary>
            Messaging system delivering messages to the particular working thread.
            </summary>
            <remarks>
            Each input channel is represented by its own working thread removing messages from the queue and processing them
            one by one.
            <br/><br/>
            Different instances of ThreadMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message with this messaging system
            then output and input channels must be created by the same instance of ThreadMessagingSystemFactory.
            <br/><br/>
            Notice, the messages are always received in one particular working thread, but the notification events e.g. connection opened
            are invoked in a different thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.#ctor">
            <summary>
            Constructs thread based messaging factory.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs thread based messaging factory.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
            <param name="protocolFormatter">low-level message formatter for the communication between channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel and receiving response messages by using the working thread.
            </summary>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the output channel sending messages to the input channel and receiving response messages by using the working thread.
            </summary>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel and sending back response messages by using the working thread.
            </summary>
            <param name="channelId">Identifies this duplex input channel.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.InputChannelThreading">
            <summary>
            Threading mode for input channels.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Threading mode for output channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.NamespaceDoc">
            <summary>
            Communication routing messages into one working thread.
            </summary>
            <remarks>
            The messaging system transferring messages to a working thread.
            Received messages are stored in the queue which is then processed by one working thread.
            Therefore the messages are processed synchronously but it does not block receiving. 
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory">
            <summary>
            Messaging system delivering messages asynchronously (when a message is received a separate thread is invoked to process it).
            </summary>
            <remarks>
            Each incoming message is routed into its own thread from the pool. It means when a message is received the thread
            from the pool is taken and the message is notified.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="protocolFormatter">formatter used to encode low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the thread pool.
            </summary>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the thread pool.
            </summary>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using the thread pool.
            </summary>
            <param name="channelId">Identifies this duplex input channel.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.InputChannelThreading">
            <summary>
            Threading mode for input channels.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Threading mode for output channels.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.NamespaceDoc">
            <summary>
            Asynchronous communication using multiple threads.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory">
            <summary>
            Messaging system delivering messages via UDP.
            </summary>
            <remarks>
            It creates the communication channels using UDP for sending and receiving messages.
            The channel id must be a valid UDP URI address. E.g.: udp://127.0.0.1:6080/. <br/>
            The messaging via UDP supports unicast, multicast and broadcast communication.<br/>
            The unicast communication is the routing of messages from one sender to one receiver.
            (E.g. a client-service communication where a client sends messages to one service and the service 
            can send response messages to one client.)<br/> 
            The multicast communication is the routing of messages from one sender to multiple receivers
            (the receivers which joined the specific multicast group and listen to the specific port).
            The broadcast communication is the routing of messages from one sender to all receivers within the sub-net which listen
            to the specific port.<br/>
            <br/>
            <example>
            UDP unicast communication.
            <code>
            // Create UDP input channel.
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory();
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("udp://127.0.0.1:8043/");
            
            // Subscribe for receiving messages.
            anInputChannel.MessageReceived += OnMessageReceived;
            
            // Start listening.
            anInputChannel.StartListening();
            
            ...
            
            // Stop listening.
            anInputChannel.StopListening();
            
            
            // Handling of messages.
            private void OnMessageReceived(object sender, DuplexChannelMessageEventArgs e)
            {
                // Handle incoming message.
                ....
                
                // Send response message.
                IDuplexInputChannel anInputChannel = (IDuplexInputChannel)sender;
                anInputChannel.SendResponseMessage(e.ResponseReceiverId, "Hi");
            }
            </code>
            
            <code>
            // Create UDP output channel.
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://127.0.0.1:8043/");
            
            // Subscribe to receive messages.
            anOutputChannel.ResponseMessageReceived += OnResponseMessageReceived;
            
            // Open the connection.
            anOutputChannel.OpenConnection();
            
            ...
            
            // Send a message.
            anOutputChannel.SendMessage("Hello");
            
            ...
            // Close connection.
            anOutputChannel.CloseConnection();
            
            
            // Handling of received message.
            private void OnResponseMessageReceived(object sender, DuplexChannelMessageEventArgs e)
            {
                string aMessage = (string)e.Message;
                ....
            }
            </code>
            </example>
            
            <exanple>
            UDP multicast communication.
            <code>
            // Create UDP input channel.
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory()
            {
                // The communication will be multicast or broadcast.
                UnicastCommunication = false,
                
                // The multicast group which shall be joined.
                MulticastGroupToReceive = "234.5.6.7"
            };
            
            // This input channel will be able to receive messages sent to udp://127.0.0.1:8043/ or
            // to the multicast group udp://234.5.6.7:8043/.
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("udp://127.0.0.1:8043/")
            
            
            // Subscribe for receiving messages.
            anInputChannel.MessageReceived += OnMessageReceived;
            
            // Start listening.
            anInputChannel.StartListening();
            
            ...
            
            // Stop listening.
            anInputChannel.StopListening();
            
            
            // Handling of messages.
            private void OnMessageReceived(object sender, DuplexChannelMessageEventArgs e)
            {
                // Handle incoming message.
                ....
                
                // Send response message.
                IDuplexInputChannel anInputChannel = (IDuplexInputChannel)sender;
                anInputChannel.SendResponseMessage(e.ResponseReceiverId, "Hi");
            }
            </code>
            
            <code>
            // Create UDP output channel which will send messages to the multicast group udp://234.5.6.7:8043/.
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory()
            {
                // The communication will be multicast or broadcast.
                UnicastCommunication = false
            };
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://234.5.6.7:8043/");
            
            // Subscribe to receive messages.
            anOutputChannel.ResponseMessageReceived += OnResponseMessageReceived;
            
            // Open the connection.
            anOutputChannel.OpenConnection();
            
            ...
            
            // Send a message to all receivers which have joined
            // the multicast group udp://234.5.6.7:8043/.
            anOutputChannel.SendMessage("Hello");
            
            ...
            // Close connection.
            anOutputChannel.CloseConnection();
            
            
            // Handling of received message.
            private void OnResponseMessageReceived(object sender, DuplexChannelMessageEventArgs e)
            {
                string aMessage = (string)e.Message;
                ....
            }
            </code>
            </exanple>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the UDP messaging factory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the UDP messaging factory.
            </summary>
            <param name="protocolFromatter">formatter used for low-level messaging between output and input channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates duplex output channel which can send and receive messages from the duplex input channel using UDP.
            </summary>
            <remarks>
            It can create duplex output channels for unicast, multicast or broadcast communication.
            If the property UnicastCommunication is set to true then it creates the output channel for the unicast communication.
            It means it can send messages to one particular input channel and receive messages only from that input channel.
            If the property UnicastCommunication is set to false then it creates the output channel for mulitcast or broadcast communication.
            It means it can send mulitcast or broadcast messages which can be received by multiple input channels.
            It can also receive multicast and broadcast messages.
            <example>
            Creating the duplex output channel for unicast communication (e.g. for client-service communication).
            <code>
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://127.0.0.1:8765/");
            </code>
            </example>
            <example>
            Creating the duplex output channel for sending mulitcast messages (e.g. for streaming video to multiple receivers).
            <code>
            IProtocolFormatter aProtocolFormatter = new EasyProtocolFormatter();
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory(aProtocolFormatter)
            {
                // Setup the factory to create channels for mulitcast or broadcast communication.
                UnicastCommunication = false
            };
            
            // Create output channel which will send messages to the mulitcast group 234.4.5.6 on the port 8765.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://234.4.5.6:8765/");
            </code>
            </example>
            <example>
            Creating the duplex output channel for sending broadcast messages.
            <code>
            IProtocolFormatter aProtocolFormatter = new EasyProtocolFormatter();
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory(aProtocolFormatter)
            {
                // Setup the factory to create channels for mulitcast or broadcast communication.
                UnicastCommunication = false,
                
                // Setup the factory to create chennels which are allowed to send broadcast messages.
                AllowSendingBroadcasts = true
            };
            
            // Create output channel which will send broadcast messages to the port 8765.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://255.255.255.255:8765/");
            </code>
            </example>
            </remarks>
            <param name="channelId">UDP address in a valid URI format e.g. udp://127.0.0.1:8090/</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates duplex output channel which can send and receive messages from the duplex input channel using UDP.
            </summary>
            <remarks>
            It can create duplex output channels for unicast, multicast or broadcast communication.
            If the property UnicastCommunication is set to true then it creates the output channel for the unicast communication.
            It means it can send messages to one particular input channel and receive messages only from that input channel.
            If the property UnicastCommunication is set to false then it creates the output channel for mulitcast or broadcast communication.
            It means it can send mulitcast or broadcast messages which can be received by multiple input channels.
            It can also receive multicast and broadcast messages.<br/>
            <br/>
            This method allows to specify the id of the created output channel.
            <example>
            Creating the duplex output channel for unicast communication (e.g. for client-service communication)
            with a specific output channel id.
            <code>
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory();
            string aSessionId = Guid.NewGuid().ToString();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://127.0.0.1:8765/", aSessionId);
            </code>
            </example>
            <example>
            Creating the duplex output channel which can send messages to a particular UDP address and
            which can recieve messages on a specific UDP address and which can receive mulitcast messages.
            <code>
            IProtocolFormatter aProtocolFormatter = new EasyProtocolFormatter();
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory(aProtocolFormatter)
            {
                // Setup the factory to create channels for mulitcast or broadcast communication.
                UnicastCommunication = false,
                
                // Specify the mulitcast group to receive messages from.
                MulticastGroupToReceive = "234.4.5.6"
            };
            
            // Create output channel which can send messages to the input channel listening to udp://127.0.0.1:8095/
            // and which is listening to udp://127.0.0.1:8099/ and which can also receive messages sent for the mulitcast
            // group 234.4.5.6.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://127.0.0.1:8095/", "udp://127.0.0.1:8099/");
            </code>
            </example>
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. udp://127.0.0.1:8090/</param>
            <param name="responseReceiverId">
            Unique identifier of the output channel.<br/>
            In unicast communication the identifier can be a string e.g. GUID which represents the session between output and input channel.<br/>
            In mulitcast or broadcast communication the identifier must be a valid URI address which will be used by the output channel
            to receive messages from input channels.<br/>
            <br/>
            If the parameter is null then in case of unicast communication a unique id is generated automatically.
            In case of multicast or broadcast communication the address udp://0.0.0.0:0/ is used which means the the output channel will
            listen to random free port on all available IP addresses.
            </param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel which can receive and send messages to the duplex output channel using UDP.
            </summary>
            <remarks>
            It can create duplex input channels for unicast, multicast or broadcast communication.
            If the property UnicastCommunication is set to true then it creates the input channel for the unicast communication.
            It means, like a service it can receive connections and messages from multiple output channels but
            send messages only to particular output channels which are connected.
            If the property UnicastCommunication is set to false then it creates the output channel for mulitcast or broadcast communication.
            It means it can send mulitcast or broadcast messages which can be received by multiple output channels.
            It also can receive multicast and broadcast messages.
            <example>
            Creating the duplex input channel for unicast communication.
            <code>
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory();
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("udp://127.0.0.1:8765/");
            </code>
            </example>
            <example>
            Creating the duplex input channel for multicast communication.
            <code>
            IProtocolFormatter aProtocolFormatter = new EasyProtocolFormatter();
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory(aProtocolFormatter)
            {
                // Setup the factory to create channels for mulitcast or broadcast communication.
                UnicastCommunication = false,
                
                // Specify the mulitcast group to receive messages from.
                MulticastGroupToReceive = "234.4.5.6"
            }
            
            // Create duplex input channel which is listening to udp://127.0.0.1:8095/ and can also receive multicast messages
            // sent to udp://234.4.5.6:8095/.
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("udp://127.0.0.1:8095/");
            </code>
            </example>
            <example>
            Sending mulitcast and broadcast messages from the duplex input channel.
            <code>
            IProtocolFormatter aProtocolFormatter = new EasyProtocolFormatter();
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory(aProtocolFormatter)
            {
                // Setup the factory to create channels for mulitcast or broadcast communication.
                UnicastCommunication = false,
                
                // Setup the factory to create chennels which are allowed to send broadcast messages.
                AllowSendingBroadcasts = true
            }
            
            // Create duplex input channel which is listening to udp://127.0.0.1:8095/.
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("udp://127.0.0.1:8095/");
            
            // Subscribe to handle messages.
            anIputChannel.MessageReceived += OnMessageReceived;
            
            // Start listening.
            anIputChannel.StartListening();
            
            ...
            
            // Send a multicast message.
            // Note: it will be received by all output and input channels which have joined the multicast group 234.4.5.6
            // and are listening to the port 8095.
            anInputChannel.SendResponseMessage("udp://234.4.5.6:8095/", "Hello");
            
            ...
            
            // Send a broadcast message.
            // Note: it will be received by all output and input channels within the sub-network which are listening to the port 8095.
            anInputChannel.SendResponseMessage("udp://255.255.255.255:8095/", "Hello");
            
            ...
            
            // Stop listening.
            anInputChannel.StopListening();
            </code>
            </example>
            </remarks>
            <param name="channelId">Identifies this duplex input channel. The channel id must be a valid URI address (e.g. udp://127.0.0.1:8090/) the input channel will listen to.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.GetAvailableIpAddresses">
            <summary>
            Returns IP addresses assigned to the device which can be used for listening.
            </summary>
            <returns>array of available addresses</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.IsPortAvailableForUdpListening(System.String)">
            <summary>
            Checks if the port is available for UDP listening.
            </summary>
            <param name="ipAddressAndPort">IP address and port.</param>
            <example>
            Check if the application can start listening on the IP address 127.0.0.1 and the port 8099.
            <code>
            bool isPortAvailable = UdpMessagingSystemFactory.IsPortAvailableForUdpListening("127.0.0.1:8099");
            </code>
            </example>
            <returns>true if the port is available</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.UnicastCommunication">
            <summary>
            Sets or gets whether the communication is unicast.
            </summary>
            <remarks>
            If true the factory will create channels for unicast communication. 
            The unicast is the communication between one sender and one receiver. It means if a sender sends a message it is
            routed to one particular receiver. The client-service communication is an example of the unicast communication.
            When the client sends a request message it is delivered to one service. Then when the service sends a response message
            it is delivered to one client.<br/>
            If false the factory will create channels for multicast or broadcast communication which is the communication between
            one sender and several receivers. It means when a sender sends a mulitcast or a broadcast message the message may be
            delivered to multiple receivers. E.g. in case of video streaming the sender does not send data packets individually to
            each receiver but it sends it just ones and routers multiply it and deliver it to all receivers.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.Ttl">
            <summary>
            Sets or gets time to live value for UDP datagrams.
            </summary>
            <remarks>
            When an UDP datagram is traveling across the network each router decreases its TTL value by one.
            Once the value is decreased to 0 the datagram is discarded. Therefore the TTL value specifies
            how many routers a datagram can traverse.<br/>
            E.g. if the value is set to 1 the datagram will not leave the local network.<br/>
            The default value is 128.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.MulticastGroupToReceive">
            <summary>
            Sets or gets the multicast group to receive messages from.
            </summary>
            <remarks>
            Multicast group (multicast address) is a an IP address which is from the range 224.0.0.0 - 239.255.255.255.
            (The range from 224.0.0.0 to 224.0.0.255 is reserved for low-level routing protocols and you should not use it in your applications.)
            Receiving messages from the mulitcast group means the communication is not unicast but mulitcast.
            Therefore to use this property UnicastCommunication must be set to false.
            <example>
            Creating input channel which can receive multicast messages.
            <code>
            // Create UDP messaging factory using simple protocol formatter.
            IProtocolFormatter aProtocolFormatter = new EasyProtocolFormatter();
            UdpMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory(aProtocolFormatter)
            {
                // Setup messaging factory to create channels for mulitcast or broadcast communication.
                UnicastCommunication = false,
            
                // Set the multicast group which shall be joined for receiving messages.
                MulticastGroupToReceive = "234.5.6.7"
            };
            
            // Create input channel which will listen to udp://192.168.30.1:8043/ and which will also
            // receive messages from the multicast group udp://234.5.6.7:8043/.
            IInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("udp://192.168.30.1:8043/");
            </code>
            </example>
            <example>
            Creating output channel which can send multicast messages.
            <code>
            // Create UDP messaging factory using simple protocol formatter.
            IProtocolFormatter aProtocolFormatter = new EasyProtocolFormatter();
            UdpMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory(aProtocolFormatter)
            {
                // Setup messaging factory to create channels for mulitcast or broadcast communication.
                UnicastCommunication = false
            };
            
            // Create output channel which can send messages to the multicast address udp://234.5.6.7:8043/.
            IOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://234.5.6.7:8043/");
            </code>
            </example>
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.AllowSendingBroadcasts">
            <summary>
            Enables / disables sending broadcast messages.
            </summary>
            <remarks>
            Broadcast is a message which is routed to all devices within the sub-network.
            To be able to send broadcasts UnicastCommunication must be set to false.
            <example>
            Output channel which can send broadcast messages to all input channels within the sub-network
            which listen to the port 8055.
            <code>
            // Create UDP messaging factory using simple protocol formatter.
            IProtocolFormatter aProtocolFormatter = new EasyProtocolFormatter();
            UdpMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory(aProtocolFormatter);
            
            // Setup messaging factory to create channels for mulitcast or broadcast communication.
            aMessaging.UnicastCommunication = false;
            
            // Enable sending broadcasts.
            aMessaging.AllowSendingBroadcasts = true;
            
            // Create output channel which will send broadcast messages to all devices within the sub-network
            // which listen to the port 8055.
            IOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://255.255.255.255:8055/");
            
            // Initialize output channel for sending broadcast messages and receiving responses.
            anOutputChannel.OpenConnection();
            
            // Send UDP broadcast.
            anOutputChannel.SendMessage("Hello");
            
            ...
            
            // Close channel - it will release listening thread.
            anOutputChannel.CloseConnection();
            </code>
            </example>
            
            <example>
            Input channel which can receive broadcast messages.
            <code>
            // Create UDP messaging factory using simple protocol formatter.
            IProtocolFormatter aProtocolFormatter = new EasyProtocolFormatter();
            UdpMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory(aProtocolFormatter);
            
            // Setup messaging factory to create channels for mulitcast or broadcast communication.
            aMessaging.UnicastCommunication = false;
            
            // Create input channel which can receive broadcast messages to the port 8055.
            IInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("udp://0.0.0.0:8055/");
            
            // Subscribe to receive messages.
            anInputChannel.MessageReceived += OnMessageReceived;
            
            // Start listening for messages.
            anInputChannel.StartListening();
            
            ...
            
            // Stop listening.
            anInputChannel.StopListening();
            </code>
            </example>
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.MulticastLoopback">
            <summary>
            Enables /disables receiving multicast messages from the same IP address from which they were sent.
            </summary>
            <remarks>
            In case the sender sends a message to the same multicast group and port as itself has joined this value
            specifies whether it shall also receive the message or not. It means if it shall send the message to itself.
            If the value is true then yes the message will be delivered to sender too.
            Default value is true.
            <example>
            Sending multicast message from the output channel and receiving it by the same output channel.
            <code>
             UdpMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory(new EasyProtocolFormatter())
             {
                 UnicastCommunication = false,
                 MulticastGroupToReceive = "234.1.2.3",
                 MulticastLoopback = true
             };
            
             ManualResetEvent aMessageReceived = new ManualResetEvent(false);
             string aReceivedMessage = null;
             IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://234.1.2.3:8090/", "udp://0.0.0.0:8090/");
             anOutputChannel.ResponseMessageReceived += (x, y) =&gt;
             {
                 aReceivedMessage = (string)y.Message;
                 aMessageReceived.Set();
             };
            
             try
             {
                 anOutputChannel.OpenConnection();
                 anOutputChannel.SendMessage("Hello");
                 aMessageReceived.WaitIfNotDebugging(1000);
             }
             finally
             {
                 anOutputChannel.CloseConnection();
             }
            
             Assert.AreEqual("Hello", aReceivedMessage);
            </code>
            </example>
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.ResponseReceiverPort">
            <summary>
            Sets or gets the port which shall be used for receiving response messages by output channel in case of unicast communication.
            </summary>
            <remarks>
            When a client connects an IP address and port for the unicast communication a random free port is assigned for receiving messages.
            This property allows to use a specific port instead of random one.
            This property works only for the unicast communication.<br/>
            <br/>
            Default value is -1 which means a random free port is chosen for receiving response messages.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.MaxAmountOfConnections">
            <summary>
            Sets or gets the maximum number of connections the input channel can accept.
            </summary>
            <remarks>
            This property is meaningful only for the unicast UDP communication. I.e. for the communication between one sender
            and one receiver.<br/>
            The default value is -1 and it means the amount of connections is not restricted.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.InputChannelThreading">
            <summary>
            Sets or gets the threading mode for input channels.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Sets or gets the threading mode for output channels.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.ReuseAddress">
            <summary>
            Sets or gets the flag indicating whether the socket can be bound to the address which is already used.
            </summary>
            <remarks>
            If the value is true then the input channel or output channel can start listening to the IP address and port which is already in use by other channel.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.NamespaceDoc">
            <summary>
            Communication via UDP.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType">
            <summary>
            Defines data frames as specified by the websocket protocol.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Continuation">
            <summary>
            Frame contains message data that was not sent in one 'Text' or 'Binary'.
            Message that is split into multiple frames.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Text">
            <summary>
            Frame contains UTF8 text message data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Binary">
            <summary>
            Frame contains binary data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Close">
            <summary>
            Control frame indicating the connection goes down.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Ping">
            <summary>
            Control frame pinging the end-point (client or server). The pong response is expected.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Pong">
            <summary>
            Control frame as a response for the ping.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext">
            <summary>
            Represents the client on the server side.
            </summary>
            <remarks>
            The client context is obtained when a client opened the connection with the server.
            It provides functionality to receive messages from the client and send back response messages.
            To see the example refer to  <see cref="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener"/>.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.ConnectionClosed">
            <summary>
            The event is invoked when the connection with the client was closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.PongReceived">
            <summary>
            The event is invoked when the pong message was received.
            </summary>
            <remarks>
            The pong message is sent as a response to ping. According to websocket protocol
            unsolicit pong can be sent too. (i.e. it does not have to be a response to a ping)<br/>
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.ClientEndPoint">
            <summary>
            Returns the IP address of the connected client.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.IsConnected">
            <summary>
            Returns true if the client is connected.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.Uri">
            <summary>
            Returns URI of this connection including query parameters sent by the client.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.HeaderFields">
            <summary>
            Returns the readonly dictionary containing header HTTP header fields.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendTimeout">
            <summary>
            Sets or gets the send timeout in miliseconds. Default value is 0 what is infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.ReceiveTimeout">
            <summary>
            Sets or gets the receive timeout in miliseconds. Default value is 0 what is infinite time.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendMessage(System.Object)">
            <summary>
            Sends message to the client.
            </summary>
            <remarks>
            The message must be type of string or byte[]. If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.
            </remarks>
            <param name="data">message to be sent to the client. Must be byte[] or string.</param>
            <exception cref="T:System.ArgumentException">input parameter is not string or byte[].</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendMessage(System.Object,System.Boolean)">
            <summary>
            Sends message to the client. Allows to send the message via multiple frames.
            </summary>
            <remarks>
            The message must be type of string or byte[]. If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.<br/>
            <br/>
            It allows to send the message in multiple frames. The client then can receive all parts separately
                
            <example>
            The following example shows how to send 'Hello world.' in three parts.
            <code>
            void ProcessConnection(IWebSocketClientContext clientContext)
            {
                ...
                
                // Send the first part of the message.
                clientContext.SendMessage("Hello ", false);
                
                // Send the second part.
                clientContext.SendMessage("wo", false);
                
                // Send the third final part.
                clientContext.SendMessage("rld.", true);
                
                ...
            }
            </code>
            </example>
            </remarks>
            <param name="data">message to be sent to the client. The message can be byte[] or string.</param>
            <param name="isFinal">true if this is the last part of the message.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.ReceiveMessage">
            <summary>
            Waits until a message is received from the client.
            </summary>
            <remarks>
            <example>
            Example shows how to implement a loop receiving the text messages from the client.
            <code>
            void ProcessConnection(IWebSocketClientContext clientContext)
            {
                // The loop waiting for incoming messages.
                // Note: The waiting thread is released when the connection is closed.
                WebSocketMessage aWebSocketMessage;
                while ((aWebSocketMessage = clientContext.ReceiveMessage()) != null)
                {
                    if (aWebSocketMessage.IsText)
                    {
                        // Wait until all data frames are collected
                        // and return the message.
                        string aMessage = aWebSocketMessage.GetWholeTextMessage();
                        ...
                    }
                }
            }
            </code>
            </example>
            </remarks>
            <returns>message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendPing">
            <summary>
            Pings the client. According to websocket protocol, pong should be responded.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendPong">
            <summary>
            Sends unsolicited pong to the client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.CloseConnection">
            <summary>
            Closes connection with the client.
            </summary>
            <remarks>
            It sends the close message to the client and closes the underlying tcp connection.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient">
            <summary>
            WebSocket client.
            </summary>
            <remarks>
            Represents the client for the websocket communication.
            <example>
            The following example shows how to communicate with a websocket server.
            <code>
            WebSocketClient aClient = new WebSocketClient("ws://127.0.0.1:8045/MyService/");
            
            // Subscribe to receive messages.
            aClient.MessageReceived += OnResponseMessageReceived;
            
            // Open the connection.
            aClient.OpenConnection();
            
            // Send a text message.
            aClient.SendMessage("Hello.");
            
            ....
            
            // Handler of response messages.
            void OnResponseMessageReceived(object sender, WebSocketMessage e)
            {
                // Read the whole text message.
                if (e.IsText)
                {
                    string aMessage = e.GetWholeTextMessage();
                    ...
                }
            }
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.ConnectionOpened">
            <summary>
            Event is invoked when the connection is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.ConnectionClosed">
            <summary>
            Event is invoked when the connection is closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.PongReceived">
            <summary>
            Event is invoked when the pong is received. E.g. when the server responded ping.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.MessageReceived">
            <summary>
            The event is invoked when a data message from server is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.#ctor(System.Uri)">
            <summary>
            Constructs the websocket client.
            </summary>
            <param name="uri">websocket uri address. Provide port number too. e.g. ws://127.0.0.1:8055/myservice/<br/>
            You can also specify the query that can be used to pass some open connection related parameters.
            e.g. ws://127.0.0.1:8055/myservice/?param1=10&amp;param2=20
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.#ctor(System.Uri,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory)">
            <summary>
            Constructs the websocket client.
            </summary>
            <param name="uri">websocket uri address. Provide port number too. e.g. ws://127.0.0.1:8055/myservice/<br/>
            You can also specify the query that can be used to pass some open connection related parameters.
            e.g. ws://127.0.0.1:8055/myservice/?param1=10&amp;param2=20
            </param>
            <param name="clientSecurityFactory">
            Factory allowing SSL communication. <see cref="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory"/>
            </param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.ConnectTimeout">
            <summary>
            Sets or gets the connection timeout in miliseconds. Default value is 30000 miliseconds.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendTimeout">
            <summary>
            Sets or gets the send timeout in miliseconds. Default value is 30000 miliseconds.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.ReceiveTimeout">
            <summary>
            Sets or gets the receive timeout in miliseconds. If exceeded the connection is closed. Default value is -1 infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.Uri">
            <summary>
            Returns address of websocket server.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.HeaderFields">
            <summary>
            Allows to get and set header-fields which shall be sent in open connection request.
            </summary>
            <remarks>
            It allows to add your custom header fields that shell be sent in the open connection request.
            The header-field Sec-WebSocket-Key is generated and added when OpenConnection() is called.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.ResponseReceivingPort">
            <summary>
            Sets or gets the port which shall be used for receiving response messages.
            </summary>
            <remarks>
            When a client opens a connection a random free port is assigned for receiving messages.
            This property allows to use a speciefied port instead of random one.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.IsConnected">
            <summary>
            Returns true if the connection to the server is open.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.LocalEndPoint">
            <summary>
            Returns the IP address of the client used for the communication with the server.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.OpenConnection">
            <summary>
            Opens connection to the websocket server.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.CloseConnection">
            <summary>
            Closes connection with the webscocket server.
            </summary>
            <remarks>
            It sends the close message to the service and closes the underlying tcp connection.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendMessage(System.Object)">
            <summary>
            Sends message to the server.
            </summary>
            <remarks>
            The message must be type of string or byte[].
            If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.
            </remarks>
            <param name="data">message to be sent. Must be byte[] or string.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendMessage(System.Object,System.Boolean)">
            <summary>
            Sends message to the server. Allows to send the message via multiple frames.
            </summary>
            <remarks>
            The message must be type of string or byte[].
            If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.<br/>
            <br/>
            It allows to send the message in multiple frames. The server then can receive all parts separately
            using WebSocketMessage.InputStream or as a whole message using WebSocketMessage.GetWholeMessage().
            <example>
            The following example shows how to send 'Hello world.' in three parts.
            <code>
                ...
                
                // Send the first part of the message.
                client.SendMessage("Hello ", false);
                
                // Send the second part.
                client.SendMessage("wo", false);
                
                // Send the third final part.
                client.SendMessage("rld.", true);
                
                ...
            </code>
            </example>
            </remarks>
            <param name="data"></param>
            <param name="isFinal"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendPing">
            <summary>
            Pings the service. According to websocket protocol, pong should be responded.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendPong">
            <summary>
            Sends unsolicited pong to the service.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener">
            <summary>
            WebSocket server.
            </summary>
            <remarks>
            <example>
            The following example implements a simple service echoing the incoming message back to the client.
            <code>
            using System;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace EchoService
            {
               class Program
               {
                   static void Main(string[] args)
                   {
                       WebSocketListener aService = new WebSocketListener(new Uri("ws://127.0.0.1:8045/Echo/"));
            
                       aService.StartListening(client =>
                       {
                           WebSocketMessage aMessage;
                           while ((aMessage = client.ReceiveMessage()) != null)
                           {
                               object aData;
                               if (aMessage.IsText)
                               {
                                   aData = aMessage.GetWholeTextMessage();
                               }
                               else
                               {
                                   aData = aMessage.GetWholeMessage();
                               }
            
                               // Send echo.
                               client.SendMessage(aData);
                           }
                       });
            
                       Console.WriteLine("WebSocket service is listening. Press Enter to stop.");
                       Console.ReadLine();
            
                       aService.StopListening();
                   }
               }
            }
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.WebSocketListenerImpl">
            <summary>
            Wraps the the implementation of the path listener to a separate class because PathListenerProviderBase
            shall be visible only internally.
            In addition, the documentation needs to be generated for WebSocketListener - therefore all methods
            would have to be overriden to have its own specific help description.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.#ctor(System.Uri)">
            <summary>
            Construct websocket service.
            </summary>
            <param name="webSocketUri">service address. Provide port number too.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.#ctor(System.Uri,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory)">
            <summary>
            Construct websocket service.
            </summary>
            <param name="webSocketUri">service address. Provide port number too.</param>
            <param name="securityFactory">
            Factory allowing SSL communication. <see cref="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory"/>
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.StartListening(System.Action{Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext})">
            <summary>
            Starts listening.
            </summary>
            <remarks>
            To handle connected clients the connectionHandler delegate is called. The connectionHandler delegate
            is called in parallel from multiple threads as clients are connected.
            </remarks>
            <param name="connectionHandler">callback delegate handling incoming connections. It is called 
            from multiple threads.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.StopListening">
            <summary>
            Stops listening and closes all open connections with clients.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.IsListening">
            <summary>
            Returns true if the service is listening.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.ReuseAddress">
            <summary>
            Sets or gets the flag indicating whether the socket can be bound to the address which is already used.
            </summary>
            <remarks>
            If the value is true then the duplex input channel can start listening to the IP address and port which is already used by other channel.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.MaxAmountOfClients">
            <summary>
            Sets or gets the maximum amount of clients which can connect the the listener.
            </summary>
            <remarks>
            The default value is -1 which means the amount of connected clients is not restrected.<br/>
            If the connecting client exceeds the maximum amount the client is not connected and its TCP socket is closed.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage">
            <summary>
            Represents a data message received via websocket communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.#ctor(System.Boolean,System.IO.Stream)">
            <summary>
            Constructs the message - only eneter framework can construct it.
            </summary>
            <param name="isText">true if it is a text message.</param>
            <param name="inputStream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.GetWholeMessage">
            <summary>
            Returns the whole incoming message.
            </summary>
            <remarks>
            In case the message was sent via multiple frames it waits until all frames are
            collected and then returns the result message.
            </remarks>
            <returns>received message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.GetWholeTextMessage">
            <summary>
            Returns the whole incoming text message.
            </summary>
            <remarks>
            In case the message was sent via multiple frames it waits until all frames are
            collected and then returns the result message.<br/>
            To receive message as a text message, according to websocket protocol the message
            must be sent via the text frame.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The message wsa not sent/received as the text message.
            I.e. the message was not sent via the text frame.
            </exception>
            <returns>received text message</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.IsText">
            <summary>
            Returns true if the message is text. The message is text when sent via text frame.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.InputStream">
            <summary>
            Returns the input stream user can use to read the message from.
            </summary>
            <remarks>
            The reading of the stream blocks if desired amount of data is not available and
            not all message frames were received.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory">
            <summary>
            Messaging system delivering messages via websockets.
            </summary>
            <remarks>
            It creates the communication channels using WebSockets for sending and receiving messages.
            The channel id must be a valid URI address. E.g.: ws://127.0.0.1:6080/MyService/.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.#ctor">
            <summary>
            Constructs the WebSocket messaging factory.
            </summary>
            <remarks>
            The ping frequency is set to default value 5 minutes.
            The pinging is intended to keep the connection alive in
            environments that would drop the connection if not active for some time.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the WebSocket messaging factory.
            </summary>
            <param name="protocolFormatter">formatter used for low-level messaging between output and input channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using WebSocket.
            </summary>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. ws://127.0.0.1:8090/MyService/</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using WebSocket.
            </summary>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. ws://127.0.0.1:8090/</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using WebSocket.
            </summary>
            <param name="channelId">Identifies this duplex input channel. The channel id must be a valid URI address (e.g. ws://127.0.0.1:8090/MyService/) the input channel will listen to.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ServerSecurityStreamFactory">
            <summary>
            Sets or gets the security stream factory for the server.
            If the factory is set, then the input channel and the duplex input channel use it to establish
            the secure communication.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ClientSecurityStreamFactory">
            <summary>
            Sets and gets the security stream factory for the client.
            If the factory is set, then the output channel and the duplex output channel use it to establish
            the secure communication.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ResponseReceiverPort">
            <summary>
            Sets or gets the port which shall be used for receiving response messages in output channels.
            </summary>
            <remarks>
            When a client connects an IP address and port a random free port is assigned for receiving messages.
            This property allows to use a specific port instead of random one.<br/>
            <br/>
            Default value is -1 which means a random free port is chosen for receiving response messages.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ConnectTimeout">
            <summary>
            Sets ot gets timeout to open the connection. Default is 30000 miliseconds. Value 0 is infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.SendTimeout">
            <summary>
            Sets or gets timeout to send a message. Default is 0 what it infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ReceiveTimeout">
            <summary>
            Sets or gets timeout to receive a message. If not received within the time the connection is closed. Default is 0 what it infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ReuseAddress">
            <summary>
            Sets or gets the flag indicating whether the socket can be bound to the address which is already used.
            </summary>
            <remarks>
            If the value is true then the duplex input channel can start listening to the IP address and port which is already used by other channel.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.MaxAmountOfConnections">
            <summary>
            Sets or gets the maximum amount of connections the input channel can handle.
            </summary>
            <remarks>
            The default value is -1 which means the amount of connections is not restrected.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.InputChannelThreading">
            <summary>
            Sets or gets the threading mode for input channels.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Sets or gets the threading mode for output channels.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.PingFrequency">
            <summary>
            Ping frequency.
            </summary>
            <remarks>
            The pinging is intended to keep the connection alive in
            environments that would drop the connection if not active for some time.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.NamespaceDoc">
            <summary>
            Communication via Websockets.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.NamespaceGroupDoc">
            <summary>
            Communication protocols and message transportation.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.RemoveAllReceivers">
            <summary>
            Cleans the list with available receivers. Existing connections are not broken.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.OnResponseReceiverConnected(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs)">
            <summary>
            It is called when a client opens the connection to this backup router.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.OnResponseReceiverDisconnected(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs)">
            <summary>
            It is called when the client actively closed the connection with this backup router.
            It will close the associated connection with the service.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.OnRequestMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            It is called when a message is received from a client connected to this Backup Router.
            The message will be forwarded to the connected service.
            If the sending fails the connection is considered broken it will try to reconnect with the next 
            available service and send the message again.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.OnOutputChannelResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            It is called when a response message from the service is received.
            The response message must be redirected to the associated client.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.OnOutputChannelConnectionClosed(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs)">
            <summary>
            It is called when a connection with the receiver is broken.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouterFactory">
            <summary>
            Factory creating backup connection router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouterFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="outputMessagingFactory">messaging system used to connect services (receivers) via the duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouterFactory.CreateBackupConnectionRouter">
            <summary>
            Creates the backup connection router.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter">
            <summary>
            Declares the router providing a possibility to reconnect with a backup service in case of a disconnection.
            </summary>
            <remarks>
            The backup router is a component that forwards incoming messages to a connected service (receiver).
            In case the connection with the receiver is broken it takes the next service from the list and opens the new connection.
            If it is at the end of the list it starts from the beginning.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.ConnectionRedirected">
            <summary>
            The event is invoked when the connection was broken but it was successfully reopened with the next service from the list.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.AllRedirectionsFailed">
            <summary>
            The event is invoked when it failed to connect to all available receivers.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.AvailableReceivers">
            <summary>
            Returns all available receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.AddReceiver(System.String)">
            <summary>
            Adds the service to the list.
            </summary>
            <param name="channelId">address of the service</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.AddReceivers(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds services to the list.
            </summary>
            <param name="channelIds">addresses of the service</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.RemoveReceiver(System.String)">
            <summary>
            Removes the service from the list. If there are connections to this receiver then they will be closed and redirected.
            </summary>
            <param name="channelId">address of the service</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.RemoveAllReceivers">
            <summary>
            Removes the service from the list. It will close all connections.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouterFactory">
            <summary>
            Declares the factory for creating the backup connection router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouterFactory.CreateBackupConnectionRouter">
            <summary>
            Creates the backup connection router.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.BackupRouter.RedirectEventArgs">
            <summary>
            The event data available when the original connection is replaced with new connection.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.RedirectEventArgs.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="forResponseReceiverId">Client connected to the backup router for which the connection was redirected.</param>
            <param name="fromAddress">Original service address.</param>
            <param name="toAddress">New service address.</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.BackupRouter.RedirectEventArgs.ForResponseReceiverId">
            <summary>
            Gets client connected to the backup router for which the connection was redirected.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.BackupRouter.RedirectEventArgs.FromAddress">
            <summary>
            Gets original service address.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.BackupRouter.RedirectEventArgs.ToAddress">
            <summary>
            Gets new service address.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.BackupRouter.NamespaceDoc">
            <summary>
            Automatic routing to a backup server in case of a disconnection.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.EBrokerRequest">
            <summary>
            Specifies the internal broker request inside the <see cref="T:Eneter.Messaging.Nodes.Broker.BrokerMessage"/>.
            </summary>
            <remarks>
            The request for the broker is the message that is intended for the broker and not for the subscribers.
            This message is used by the broker client to subscribe and unsubscribe.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Subscribe">
            <summary>
            Request to subscribe exactly for the specified message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Unsubscribe">
            <summary>
            Request to unsubscribe from exactly specified message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.UnsubscribeAll">
            <summary>
            Request to unsubscribe all messages and regular expressions.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Publish">
            <summary>
            Request to publish a message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerMessage">
            <summary>
            Internal message used between DuplexBroker and DuplexBrokerClient.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessage.#ctor">
            <summary>
            Default constructor used by a deserializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessage.#ctor(Eneter.Messaging.Nodes.Broker.EBrokerRequest,System.String[])">
            <summary>
            Constructs the message requesting the broker to subscribe or unsubscribe events.
            </summary>
            <param name="request">subscribing or unsubscribing</param>
            <param name="messageTypes">events to be subscribed or unsubscribed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessage.#ctor(System.String,System.Object)">
            <summary>
            Constructs the broker message requesting the broker to publish an event.
            </summary>
            <param name="messageTypeId">message type that shall be published</param>
            <param name="message">serialized message to be published</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessage.Request">
            <summary>
            Type of the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessage.MessageTypes">
            <summary>
            Array of message types.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessage.Message">
            <summary>
            Serialized message that shall be notified to subscribers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs">
            <summary>
            Event arguments of the received message from the broker.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.String,System.Object)">
            <summary>
            Constructs the event from the input parameters.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.Exception)">
            <summary>
            Constructs the event from the error detected during receiving of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.MessageTypeId">
            <summary>
            Returns type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.AuthorizeBrokerRequestCallback">
            <summary>
            Delegate is called when broker receives the request to Publish, Subscribe or Unsubscribe from BrokerDuplexClient.
            </summary>
            <param name="responseReceiverId">id of client which sent the request.</param>
            <param name="request">request sent by the client.</param>
            <returns>true if the request is valid, false if the request is invalid. If it returns false the request
            will not be invoked and the client will be disconnected.
            </returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory">
            <summary>
            Creates broker and broker client.
            </summary>
            <remarks>
            The broker is the component for publish-subscribe scenarios. It maintains the list of subscribers.
            When it receives a notification message it forwards it to subscribed clients. 
            IDuplexBrokerClient can publish messages via the broker
            and also can subscribe for desired messages.
            <example>
            The example shows how to create and use the broker communicating via TCP.
            <code>
            // Create Tcp based messaging.
            IMessagingSystemFactory aMessagingFactory = new TcpMessagingSystemFactory();
            
            // Create duplex input channel listening to messages.
            IDuplexInputChannel anInputChannel = aMessagingFactory.CreateDuplexInputChannel("tcp://127.0.0.1:7980/");
            
            // Create the factory for the broker.
            IDuplexBrokerFactory aBrokerFactory = new DuplexBrokerFactory();
            
            // Create the broker.
            IDuplexBroker aBroker = aBrokerFactory.CreateBroker();
            
            // Attach the Tcp duplex input channel to the broker and start listening.
            aBroker.AttachDuplexInputChannel(anInputChannel);
            </code>
            
            <code>
            Subscribing for the notification messages.
            
            // Create Tcp based messaging.
            IMessagingSystemFactory aTcpMessagingFactory = new TcpMessagingSystemFactory();
            
            // Create duplex output channel to send and receive messages.
            myOutputChannel = aTcpMessagingFactory.CreateDuplexOutputChannel("tcp://127.0.0.1:7980/");
            
            // Create the broker client
            IDuplexBrokerFactory aDuplexBrokerFactory = new DuplexBrokerFactory();
            myBrokerClient = aDuplexBrokerFactory.CreateBrokerClient();
            
            // Handler to process notification messages.
            myBrokerClient.BrokerMessageReceived += NotifyMessageReceived;
            
            // Attach the channel to the broker client to be able to send and receive messages.
            myBrokerClient.AttachDuplexOutputChannel(myOutputChannel);
            
            // Subscribe in broker to receive chat messages.
            myBrokerClient.Subscribe("MyChatMessageType");
            
            
            ...
            
            
            // Send message to the broker. The broker will then forward it to all subscribers.
            XmlStringSerializer anXmlSerializer = new XmlStringSerializer();
            object aSerializedChatMessage = anXmlSerializer.Serialize&lt;ChatMessage&gt;(aChatMessage);
            myBrokerClient.SendMessage("MyChatMessageType", aSerializedChatMessage);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor">
            <summary>
            Constructs the broker factory with optimized custom serializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the broker factory with specified serializer.
            </summary>
            <param name="serializer">serializer used by the broker</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            </summary>
            <remarks>
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages to receive notifications from the broker.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            </summary>
            <remarks>
            The broker receives messages and forwards them to subscribers.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.Serializer">
            <summary>
            Serializer to serialize/deserialize <see cref="T:Eneter.Messaging.Nodes.Broker.BrokerMessage"/>.
            </summary>
            <remarks>
            <see cref="T:Eneter.Messaging.Nodes.Broker.BrokerMessage"/> is used for the communication with the broker.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.SerializerProvider">
            <summary>
            Gets/sets callback for retrieving serializer based on response receiver id.
            </summary>
            <remarks>
            This callback is used by DuplexBroker when it needs to serialize/deserialize the BrokerMessage from a DuplexBrokerClient.
            Providing this callback allows to use a different serializer for each connected DuplexBrokerClient.
            This can be used e.g. if the communication with each DuplexBrokerClient needs to be encrypted using a different password.<br/>
            <br/>
            The default value is null and it means SerializerProvider callback is not used and one serializer which specified in the Serializer property is used for all serialization/deserialization.<br/>
            If SerializerProvider is not null then the setting in the Serializer property is ignored.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.BrokerRequestAuthorizer">
            <summary>
            Gets/sets callback for authorizing request messages received from DuplexBrokerClient.
            </summary>
            <remarks>
            DuplexBrokerClient can send request messages for publishing, subscribing or unsubscribing of messages.
            If the callback is not null it is called whenever such request is received from DuplexBrokerClient.
            If the callback returns true the request is considered authorized and the broker will perform it.
            If the callback returns false the request is considered invalid and will not be performed and DuplexBrokerClient
            will be disconnected.
            E.g. if a DuplexBrokerClient asks broker to publish a message and the callback returns false the message will not be sent
            to subscribers and DuplexBrokerClient will be disconnected.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.IsPublisherNotified">
            <summary>
            Sets the flag whether the publisher which sent a message shall be notified in case it is subscribed to the same message.
            </summary>
            <remarks>
            When a DuplexBrokerClient sent a message the broker forwards the message to all subscribed DuplexBrokerClients.
            In case the DuplexBrokerClient is subscribed to the same message the broker will notify it if the flag
            IsBublisherNotified is set to true.
            If it is set to false then the broker will not forward the message to the DuplexBrokerClient which
            published the message.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBroker">
            <summary>
            Broker component.
            </summary>
            <remarks>
            The broker is the communication component intended for publish-subscribe scenario.
            It is the component which allows consumers to subscribe for desired message types
            and allows publishers to send a message to subscribed consumers.<br/>
            <br/>
            When the broker receives a message from a publisher it finds all consumers subscribed to that
            message and forwards them the message.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBroker.MessagePublished">
            <summary>
            The event is invoked when the publisher published a message to subscribers.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBroker.ClientSubscribed">
            <summary>
            The event is invoked when the broker subscribed a client for messages.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBroker.ClientUnsubscribed">
            <summary>
            The event is invoked when the broker unsubscribed a client from messages.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBroker.BrokerMessageReceived">
            <summary>
            The event is invoked when the observed message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.SendMessage(System.String,System.Object)">
            <summary>
            Publishes the message.
            </summary>
            <param name="messageType">identifies the type of the published message. The broker will forward the message
            to all subscribers subscribed to this message type.</param>
            <param name="serializedMessage">message content.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Subscribe(System.String)">
            <summary>
            Subscribes for the message type.
            </summary>
            <param name="messageType">identifies the type of the message which shall be subscribed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Subscribe(System.String[])">
            <summary>
            Subscribes for list of message types.
            </summary>
            <param name="messageTypes">list of message types which shall be subscribed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Unsubscribe(System.String)">
            <summary>
            Unsubscribes from the specified message type.
            </summary>
            <param name="messageType">message type the client does not want to receive anymore.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Unsubscribe(System.String[])">
            <summary>
            Unsubscribes from specified events.
            </summary>
            <param name="messageTypes">list of message types the client does not want to receive anymore.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Unsubscribe">
            <summary>
            Unsubscribe all messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.GetSubscribedMessages(System.String)">
            <summary>
            Returns messages which are subscribed by the given subscriber.
            </summary>
            <param name="responseReceiverId">subscriber response receiver id.</param>
            <returns>subscribed messages</returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.GetSubscribedResponseReceivers(System.String)">
            <summary>
            Returns subscribers which are subscribed for the given message type id.
            </summary>
            <param name="messageTypeId">message type id</param>
            <returns>subscribed subscribers</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient">
            <summary>
            Publishes and subscribes messages in the broker.
            </summary>
            <remarks>
            The broker client is the component which interacts with the broker.
            It allows to publish messages via the broker and to subscribe for desired messages in the broker.
            <example>
            The following example shows how to subscribe a message in the broker:
            <code>
            // Create the broker client.
            IDuplexBrokerFactory aBrokerFactory = new DuplexBrokerFactory();
            IDuplexBrokerClient aBrokerClient = aBrokerFactory.CreateBrokerClient();
            
            // Register handler to process subscribed messages from the broker.
            aBrokerClient.BrokerMessageReceived += OnBrokerMessageReceived;
            
            // Attach output channel and be able to communicate with the broker.
            // E.g. if the broker communicates via TCP.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:9843/");
            aBrokerClient.AttachDuplexOutputChannel(anOutputChannel);
            
            // Now when the connection with the broker is establish so we can subscribe for
            // messages in the broker.
            // After this call whenever somebody sends the message type 'MyMessageType' into the broker
            // the broker will forward it to this broker client and the message handler
            // myMessageHandler will be called.
            aBrokerClient.Subscribe("MyMessageType");
            </code>
            The following example shows how to publish a message via the broker:
            <code>
            // Create the broker client.
            IDuplexBrokerFactory aBrokerFactory = new DuplexBrokerFactory();
            IDuplexBrokerClient aBrokerClient = aBrokerFactory.CreateBrokerClient();
            
            // Attach output channel and be able to communicate with the broker.
            // E.g. if the broker communicates via TCP.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:9843/");
            aBrokerClient.AttachDuplexOutputChannel(anOutputChannel);
            
            // Now when the connection with the broker is establish so we can publish the message.
            // Note: the broker will receive the message and will forward it to everybody who is subscribed for MyMessageType.
            aBrokerClient.SendMessage("MyMessageType", "Hello world.");
            </code>
            </example>
            
            
            
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.ConnectionOpened">
            <summary>
            Event raised when the connection with the service was open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.ConnectionClosed">
            <summary>
            Event raised when the connection with the service was closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.BrokerMessageReceived">
            <summary>
            The event is invoked when the observed event is received from the broker.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SendMessage(System.String,System.Object)">
            <summary>
            Publishes the message.
            </summary>
            <param name="messageType">identifies the type of the published message. The broker will forward the message
            to all subscribers subscribed to this message type.</param>
            <param name="serializedMessage">message content.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String)">
            <summary>
            Subscribes for the message type.
            </summary>
            <param name="messageType">identifies the type of the message which shall be subscribed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String[])">
            <summary>
            Subscribes for list of message types.
            </summary>
            <param name="messageTypes">list of message types which shall be subscribed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String)">
            <summary>
            Unsubscribes from the specified message type.
            </summary>
            <param name="messageType">message type the client does not want to receive anymore.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String[])">
            <summary>
            Unsubscribes from specified events.
            </summary>
            <param name="messageTypes">list of message types the client does not want to receive anymore.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe">
            <summary>
            Unsubscribe all messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory">
            <summary>
            Declares the factory to create the broker and the broker client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            </summary>
            <remarks>
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages to receive notifications from the broker.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            </summary>
            <remarks>
            The broker receives messages and forwards them to subscribers.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.PublishInfoEventArgs">
            <summary>
            Event argument used when the broker published a message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.PublishInfoEventArgs.#ctor(System.String,System.String,System.Object,System.Int32)">
            <summary>
            Constructs the event.
            </summary>
            <param name="publishedResponseReceiverId">response receiver id of the publisher.</param>
            <param name="publishedMessageTypeId">message type which was published.</param>
            <param name="publishedMessage">message which was published.</param>
            <param name="publishedToSubscribers">number of subscribers to which the message was published.</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.PublishInfoEventArgs.PublisherResponseReceiverId">
            <summary>
            Returns response receiver id of the publisher.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.PublishInfoEventArgs.PublishedMessageTypeId">
            <summary>
            Returns id of message type which was published.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.PublishInfoEventArgs.PublishedMessage">
            <summary>
            Returns published message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.PublishInfoEventArgs.NumberOfSubscribers">
            <summary>
            Returns number of subscribers to which the message was published.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.SubscribeInfoEventArgs">
            <summary>
            Event argument used when the broker subscribed or unsubscribed a client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.SubscribeInfoEventArgs.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructs the event.
            </summary>
            <param name="subscriberResponseReceiverId">response reciver id of subscriber</param>
            <param name="messageTypes">message ids which are subscribed or unsubscribed</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.SubscribeInfoEventArgs.SubscriberResponseReceiverId">
            <summary>
            Returns subscriber response receiver id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.SubscribeInfoEventArgs.MessageTypeIds">
            <summary>
            Returns message ids which the client subscribed or unsubscribed.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.NamespaceDoc">
            <summary>
            Publish-subscribe scenarios.
            </summary>
            <remarks>
            The broker is the communication component intended for publish-subscribe scenario.
            It is the component which allows consumers to subscribe for desired message types
            and allows publishers to send a message to subscribed consumers.<br/>
            <br/>
            When the broker receives a message from a publisher it finds all consumers subscribed to that
            message and forwards them the message.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory">
            <summary>
            Factory for creating channel wrapper and unwrapper.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor">
            <summary>
            Constructs the channel wrapper factory with XmlStringSerializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the channel wrapper factory with specified serializer.
            </summary>
            <param name="serializer">serializer used for wrapping channels with data messages.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates duplex channel unwrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.Serializer">
            <summary>
            Serializer which is used to serialize/deserialize DataWrapper.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.SerializerProvider">
            <summary>
            Gets/sets callback for retrieving serializer based on response receiver id.
            </summary>
            <remarks>
            This callback is used by DuplexChannelUnwrapper when it needs to serialize/deserialize the communication with DuplexChannelWrapper.
            Providing this callback allows to use a different serializer for each connected client.
            This can be used e.g. if the communication with each client needs to be encrypted using a different password.<br/>
            <br/>
            The default value is null and it means SerializerProvider callback is not used and one serializer which specified in the Serializer property is used for all serialization/deserialization.<br/>
            If SerializerProvider is not null then the setting in the Serializer property is ignored.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.DataWrapper">
            <summary>
            Implements the wrapper/unwrapper of data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DataWrapper.Wrap(System.Object,System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Adds the data to already serialized data.
            </summary>
            <remarks>
            It creates the <see cref="T:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData"/> from the given data and serializes it with the provided serializer.<br/>
            </remarks>
            <param name="addedData">Added data. It must a basic .Net type. Otherwise the serialization will fail.</param>
            <param name="originalData">Already serialized data - it is type of string or byte[].</param>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DataWrapper.Unwrap(System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Takes the serialized WrappedData and deserializes it with the given serializer.
            </summary>
            <param name="wrappedData">data serialized by 'Wrap' method</param>
            <param name="serializer">serializer</param>
            <returns>deserialized WrappedData</returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseReceiverDisconnected(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs)">
            <summary>
            The method is called when the response receiver is disconnected.
            The method clears all connections related to the disconnected receiver.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            Method is called when a response is received from the duplex output channel.
            It wrapps the response and sends the wrapped response to the correct response receiver as the response.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a message from the attached duplex input channel is received.
            The received message is wrapped and sent to the duplex output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a reponse message is received from the duplex output channel.
            The received response is unwrapped and sent as a response to the matching duplex input channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory">
            <summary>
            Declares the factory for creating channel wrappers and and channel unwrappers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates the duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the duplex channel unwrapper.
            </summary>
            <param name="outputMessagingSystem">Messaging used to create output channels where unwrapped messages will be sent.</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper">
            <summary>
            Duplex channel unwrapper.
            </summary>
            <remarks>
            The duplex channel wrapper is listening to more duplex input channels. When it receives some message,
            it wraps the message and sends it via the only duplex output channel.
            On the other side the message is received by duplex channel unwrapper. The unwrapper unwraps the message
            and uses the duplex output channel to forward the message to the correct receiver.<br/>
            The receiver can also send the response message. Then it goes the same way back.<br/>
            Notice, the 'duplex channel unwrapper' can communication only with 'duplex channel wrapper'.
            It cannot communicate with one-way 'channel wrapper'.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverConnected">
            <summary>
            The event is invoked when the duplex channel wrapper opened the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the duplex channel wrapper closed the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.GetAssociatedResponseReceiverId(System.String)">
            <summary>
            Returns response receiver id of the client connected to the unwrapper.
            </summary>
            <param name="responseReceiverId">responseRecieverId from unwrapped message</param>
            <returns>responseReceiverId of the client connected to the channel unwrapper. Returns null if it does not exist.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper">
            <summary>
            Duplex channel wrapper.
            </summary>
            <remarks>
            The duplex channel wrapper is listening to more duplex input channels. When it receives some message,
            it wraps the message and sends it via the only duplex output channel.
            On the other side the message is received by duplex channel unwrapper. The unwrapper unwraps the message
            and uses the duplex output channel to forward the message to the correct receiver.<br/>
            The receiver can also send the response message. Then it goes the same way back.<br/>
            Notice, the 'duplex channel wrapper' can communication only with 'duplex channel unwrapper'.
            It cannot communicate with one-way 'channel unwrapper'.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper.ConnectionOpened">
            <summary>
            Event raised when the connection with the service was open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper.ConnectionClosed">
            <summary>
            Event raised when the connection with the service was closed.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData">
            <summary>
            The data structure representing the wrapped data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.#ctor(System.Object,System.Object)">
            <summary>
            Constructs wrapped data from input parameters.
            </summary>
            <param name="addedData">new data added to the original data</param>
            <param name="originalData">original data</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.AddedData">
            <summary>
            Newly added data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.OriginalData">
            <summary>
            Original (wrapped) data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.NamespaceDoc">
            <summary>
            Reducing communication via multiple channels into one channel.
            </summary>
            <remarks>
            The channel wrapper and unwrapper are components allowing to send/receive different types of messages via one channel.
            E.g. to send and receive multiple types of request messages via one IP address and port.
            <example>
            Simple service using the channel unwrapper to receive all request messages via one IP address and port.
            <code>
            namespace ServerCalculator2
            {
                // Input data for calculator requests
                public class CalculatorInputData
                {
                    public double Number1 { get; set; }
                    public double Number2 { get; set; }
                }
            
                // Output result from the calculator
                public class CalculatorOutputData
                {
                    public double Result { get; set; }
                }
            
                internal class Calculator
                {
                    public Calculator()
                    {
                        // Internal messaging used for messaging between channel unwrapper
                        // and typed message receivers.
                        // We want that requests do not block each other. So every request will be processed in its own thread.
                        IMessagingSystemFactory anInternalMessaging = new ThreadPoolMessagingSystemFactory();
            
                        // All messages are received via one channel. So we must provide "unwrapper" forwarding incoming messages
                        // to correct receivers.
                        IChannelWrapperFactory aChannelWrapperFactory = new ChannelWrapperFactory();
                        myDuplexChannelUnwrapper = aChannelWrapperFactory.CreateDuplexChannelUnwrapper(anInternalMessaging);
            
                        // To connect receivers and the unwrapper with duplex channels we can use the following helper class.
                        IConnectionProviderFactory aConnectionProviderFactory = new ConnectionProviderFactory();
                        IConnectionProvider aConnectionProvider = aConnectionProviderFactory.CreateConnectionProvider(anInternalMessaging);
            
                        // Factory to create message receivers.
                        IDuplexTypedMessagesFactory aMessageReceiverFactory = new DuplexTypedMessagesFactory();
                        
                        // Create receiver to sum two numbers.
                        mySumReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySumReceiver.MessageReceived += SumCmd; // attach method handling the request
                        aConnectionProvider.Attach(mySumReceiver, "Sum"); // attach the input channel to get messages from unwrapper
            
                        // Receiver to subtract two numbers.
                        mySubtractReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySubtractReceiver.MessageReceived += SubCmd; // attach method handling the request
                        aConnectionProvider.Attach(mySubtractReceiver, "Sub"); // attach the input channel to get messages from unwrapper
            
                        // Receiver for multiply two numbers.
                        myMultiplyReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myMultiplyReceiver.MessageReceived += MulCmd; // attach method handling the request
                        aConnectionProvider.Attach(myMultiplyReceiver, "Mul"); // attach the input channel to get messages from unwrapper
            
                        // Receiver for divide two numbers.
                        myDivideReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myDivideReceiver.MessageReceived += DivCmd; // attach method handling the request
                        aConnectionProvider.Attach(myDivideReceiver, "Div"); // attach the input channel to get messages from unwrapper
                    }
            
            
                    public void Start()
                    {
                        // We use TCP based messaging.
                        IMessagingSystemFactory aServiceMessagingSystem = new TcpMessagingSystemFactory();
                        IDuplexInputChannel anInputChannel = aServiceMessagingSystem.CreateDuplexInputChannel("tcp://127.0.0.1:8091/");
            
                        // Attach the input channel to the unwrapper and start to listening.
                        myDuplexChannelUnwrapper.AttachDuplexInputChannel(anInputChannel);
                    }
            
                    public void Stop()
                    {
                        // Detach the input channel from the unwrapper and stop listening.
                        // Note: It releases listening threads.
                        myDuplexChannelUnwrapper.DetachDuplexInputChannel();
                    }
            
                    // It is called when a request to sum two numbers was received.
                    private void SumCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 + anInputData.Number2;
            
                        Console.WriteLine("{0} + {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        mySumReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
            
                    // It is called when a request to subtract two numbers was received.
                    private void SubCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 - anInputData.Number2;
            
                        Console.WriteLine("{0} - {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        mySubtractReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
                    
            
                    // It is called when a request to multiply two numbers was received.
                    private void MulCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 * anInputData.Number2;
            
                        Console.WriteLine("{0} x {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        myMultiplyReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
            
                    // It is called when a request to divide two numbers was received.
                    private void DivCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 / anInputData.Number2;
            
                        Console.WriteLine("{0} / {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        myDivideReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
                    
            
                    // Unwrapps messages from the input channel and forwards them
                    // to corresponding output channels.
                    private IDuplexChannelUnwrapper myDuplexChannelUnwrapper;
            
                    // Paticular services listening to requests which will be forwarded from
                    // the channel unwrapper.
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; mySumReceiver;
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; mySubtractReceiver;
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; myMultiplyReceiver;
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; myDivideReceiver;
                }
            }
            </code>
            </example>
            
            <example>
            Client using channel wrapper to send all request messages one IP address and port.
            <code>
            namespace CalculatorClient2
            {
                public partial class Form1 : Form
                {
                    // Input data for calculator requests
                    public class CalculatorInputData
                    {
                        public double Number1 { get; set; }
                        public double Number2 { get; set; }
                    }
            
                    // Output result from the calculator
                    public class CalculatorOutputData
                    {
                        public double Result { get; set; }
                    }
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        // Internal messaging between message senders and channel wrapper.
                        IMessagingSystemFactory anInternalMessaging = new SynchronousMessagingSystemFactory();
            
                        // The service receives messages via one channel (i.e. it listens on one address).
                        // The incoming messages are unwrapped on the server side.
                        // Therefore the client must use wrapper to send messages via one channel.
                        IChannelWrapperFactory aChannelWrapperFactory = new ChannelWrapperFactory();
                        myDuplexChannelWrapper = aChannelWrapperFactory.CreateDuplexChannelWrapper();
            
            
                        // To connect message senders and the wrapper with duplex channels we can use the following helper class.
                        IConnectionProviderFactory aConnectionProviderFactory = new ConnectionProviderFactory();
                        IConnectionProvider aConnectionProvider = aConnectionProviderFactory.CreateConnectionProvider(anInternalMessaging);
            
                        
                        // Factory to create message senders.
                        // Sent messages will be serialized in Xml.
                        IDuplexTypedMessagesFactory aCommandsFactory = new DuplexTypedMessagesFactory();
            
                        // Sender to sum two numbers.
                        mySumSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySumSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, mySumSender, "Sum");
            
                        // Sender to subtract two numbers.
                        mySubSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySubSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, mySubSender, "Sub");
            
                        // Sender to multiply two numbers.
                        myMulSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myMulSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, myMulSender, "Mul");
            
                        // Sender to divide two numbers.
                        myDivSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myDivSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, myDivSender, "Div");
            
                        // We use Tcp for the communication.
                        IMessagingSystemFactory aTcpMessagingSystem = new TcpMessagingSystemFactory();
            
                        // Create output channel to send requests to the service.
                        IDuplexOutputChannel anOutputChannel = aTcpMessagingSystem.CreateDuplexOutputChannel("tcp://127.0.0.1:8091/");
            
                        // Attach the output channel to the wrapper - so that we are able to send messages
                        // and receive response messages.
                        // Note: The service has the coresponding unwrapper.
                        myDuplexChannelWrapper.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        // Stop listening by detaching the input channel.
                        myDuplexChannelWrapper.DetachDuplexInputChannel();
                    }
            
            
                    private void OnResultResponse(object sender, TypedResponseReceivedEventArgs&lt;CalculatorOutputData&gt; e)
                    {
                        // If everything is ok then display the result.
                        if (e.ReceivingError == null)
                        {
                            // The response does not come in main UI thread.
                            // Therefore we must transfer it to the main UI thread.
                            InvokeInUIThread(() =&gt; ResultLabel.Text = e.ResponseMessage.Result.ToString() );
                        }
                    }
            
                    private void CalculateButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(mySumSender);
                    }
                     
                    private void SubtractButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(mySubSender);
                    }
            
                    private void MultiplyButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(myMulSender);
                    }
            
                    private void DivideButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(myDivSender);
                    }
            
                    private void SendRequestMessage(IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; sender)
                    {
                        // Prepare input data for the calculator.
                        CalculatorInputData anInputForCalculator = new CalculatorInputData();
                        anInputForCalculator.Number1 = double.Parse(Number1TextBox.Text);
                        anInputForCalculator.Number2 = double.Parse(Number2TextBox.Text);
            
                        // Send the request message.
                        sender.SendRequestMessage(anInputForCalculator);
                    }
            
                    // Helper method to invoke UI always in the correct thread.
                    private void InvokeInUIThread(Action action)
                    {
                        if (InvokeRequired)
                        {
                            Invoke(action);
                        }
                        else
                        {
                            action.Invoke();
                        }
                    }
            
                    // Wraps requests into one output channel.
                    // The service side listens to one address and uses unwrapper to unwrap
                    // messages and send them to correct receivers.
                    private IDuplexChannelWrapper myDuplexChannelWrapper;
            
                    // Message senders.
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; mySumSender;
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; mySubSender;
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; myMulSender;
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; myDivSender;
                }
            }
            </code>
            </example>
            
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory">
            <summary>
            Implements factory to create the dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex dispatcher factory.
            </summary>
            <param name="duplexOutputChannelsFactory">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the duplex dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher">
            <summary>
            Dispatcher.
            </summary>
            <remarks>
            The duplex dispatcher has attached more duplex input channels and uses more duplex output channels.<br/>
            When it receives some message via the duplex input channel it forwards the message to all duplex output channels.<br/>
            The duplex dispatcher allows the bidirectional communication. It means, receivers to whom the message was forwarded can
            send back response messages. Therefore, the sender can get response messages from all receivers.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.AddDuplexOutputChannel(System.String)">
            <summary>
            Adds the duplex output channel id to the dispatcher. The dispatcher will then start to forward
            the incoming messages also to this channel.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveDuplexOutputChannel(System.String)">
            <summary>
            Removes the duplex output channel from the dispatcher.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveAllDuplexOutputChannels">
            <summary>
            Removes all duplex output channels from the dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.GetAssociatedResponseReceiverId(System.String)">
            <summary>
            Returns response receiver id of the client connected to the dispatcher.
            </summary>
            <param name="responseReceiverId">responseRecieverId after dispatching</param>
            <returns>responseReceiverId of the client connected to the dispatcher. Returns null if it does not exist.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory">
            <summary>
            Creates the dispatcher.
            </summary>
            <remarks>
            The dispatcher sends messages to all duplex output channels and also can route back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.NamespaceDoc">
            <summary>
            Multiplying and forwarding of received messages. 
            </summary>
            <remarks>
            Receives messages and forwards them to all attached receivers.
            The message is then processed by more services in parallel.
            E.g. If a client needs to evaluate results from more different services.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer">
            <summary>
            Load balancer.
            </summary>
            <remarks>
            The load balancer maintains a list of receivers processing a certain request.
            When the balancer receives the request, it chooses which receiver shall process it,
            so that all receivers are loaded optimally.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.ResponseReceiverConnected">
            <summary>
            The event is invoked when the client sending requests was connected to the load balancer.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the client sending requests was disconnected from the load balanacer.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.RequestReceiverRemoved">
            <summary>
            The event is invoked when a service receiving requests from the load balancer got disconnected.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.AddDuplexOutputChannel(System.String)">
            <summary>
            Adds the request receiver to the load balancer.
            </summary>
            <param name="channelId">channel id (address) of the receiver processing requests.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.RemoveDuplexOutputChannel(System.String)">
            <summary>
            Removes the request receiver from the load balancer.
            </summary>
            <param name="channelId">channel id (address) of the receiver processing requests.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.RemoveAllDuplexOutputChannels">
            <summary>
            Removes all request receiers from the load balanacer.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancerFactory">
            <summary>
             Creates the load balancer.
            </summary>
            <remarks>
            The load balancer distributes the workload across a farm of receivers that can run on different machines (or threads).
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancerFactory.CreateLoadBalancer">
            <summary>
            Creates the load balancer.
            </summary>
            <returns>load balancer</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.RequestReceiverRemovedEventArgs">
            <summary>
            Event which is invoked when the receiver is removed from the load balancer pool.
            </summary>
            <remarks>
            The request receiver is removed from the pool if the load balancer cannot open the connection with the receiver.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.RequestReceiverRemovedEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.LoadBalancer.RequestReceiverRemovedEventArgs.ChannelId">
            <summary>
            Returns the address of the request receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.RoundRobinBalancerFactory">
            <summary>
            Implements factory to create the load balancer based on Round-Robin algorithm.
            </summary>
            <remarks>
            The Round-Robin balancer distributes the incoming requests equally to all maintained receivers.
            It means, the balancer maintains which receiver was used the last time. Then, when a new request comes,
            the balancer picks the next receiver in the list up. If it is at the end, then it starts from the beginning.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.RoundRobinBalancerFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="duplexOutputChannelsFactory">
            messaging system used to create duplex output channels that will be used for the communication with
            services from the farm.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.RoundRobinBalancerFactory.CreateLoadBalancer">
            <summary>
            Creates the load balancer using the Round-Robin algorithm.
            </summary>
            <returns>load balancer</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.NamespaceDoc">
            <summary>
            Distributing the workload across a farm of receivers.
            </summary>
            <remarks>
            The load balancer maintains a list of receivers processing a certain request.
            When the balancer receives the request, it chooses which receiver shall process it,
            so that all receivers are loaded optimally.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.DuplexRouterFactory">
            <summary>
            Implements the factory creating duplex router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex router factory.
            </summary>
            <param name="duplexOutputChannelMessaging">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouter">
            <summary>
            Declares the duplex router.
            </summary>
            <remarks>
            The duplex router has attached more duplex input channels and uses more duplex output channels.<br/>
            When it receives some message via the duplex input channel, it forwards the message to all configured duplex output channels.<br/>
            This router is bidirectional. Therefore, it can forward messages and also route back response messages from receivers.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.AddConnection(System.String,System.String)">
            <summary>
            Adds the connection configuration to the router. It means when the duplex input channel receives a
            message then the message will be forwarded to the specified duplex output channel too.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveConnection(System.String,System.String)">
            <summary>
            Removes the connection configuration from the router.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveAllConnections">
            <summary>
            Removes all configurations from the router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory">
            <summary>
            Declares the factory creating duplex router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.NamespaceDoc">
            <summary>
            Functionality for routing messages to a different address.
            </summary>
            <remarks>
            Router receives messages and routes them to a different preconfigured address.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.NamespaceGroupDoc">
            <summary>
            Routing of messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.AsyncDispatching">
            <summary>
            Invokes asynchronously by routing to a thread from the thread-pool (each method can be executed in a separate thread).
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.AsyncDispatching.GetDispatcher">
            <summary>
            Returns dispatcher which invokes asynchronously in a thread from the thread-pool.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.IThreadDispatcher">
            <summary>
            Invokes a method according to specified thread mode.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.IThreadDispatcher.Invoke(System.Action)">
            <summary>
            Invokes method in desired thread.
            </summary>
            <param name="workItem">delegate to be invoked</param>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.IThreadDispatcherProvider">
            <summary>
            Provides dispatcher that shall be used for raising events and delivering messages in a correct thread.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.IThreadDispatcherProvider.GetDispatcher">
            <summary>
            Returns dispatcher that will invoke methods according to its threading model.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.NoDispatching">
            <summary>
            Invokes directly without routing.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.NoDispatching.GetDispatcher">
            <summary>
            Returns dispatcher which invokes directly without routing into a thread.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.SyncDispatching">
            <summary>
            Invokes one by one from from the queue.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.SyncDispatching.#ctor">
            <summary>
            Constructs dispatching where each GetDispatcher() will return new instance of the dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.SyncDispatching.#ctor(System.Boolean)">
            <summary>
            Constructor which allows to specify if GetDispatcher() returns always the same dispatcher or GetDispatcher()
            returns always the new instance the dispatcher.
            </summary>
            <param name="isDispatcherShared">
            true - GetDispatcher() will return always the same instance of the dispatcher. It means all dispatchers returned from
            GetDispatcher() will sync incoming methods using the same queue. <br/>
            false - GetDispatcher() will return always the new instance of the dispatcher. It means each dispatcher returned from
            GetDispatcher() will use its own synchronization queue.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.SyncDispatching.GetDispatcher">
            <summary>
            Returns dispatcher that queues callback methods and processes them one by one.
            </summary>
            <remarks>
            If SyncDispatching was created with isDispatcherShared true then it always returns the same instance
            of the thread dispatcher. Otherwise it always creates the new one. 
            </remarks>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.WinFormsDispatching">
            <summary>
            Invokes to WinForms main UI thread.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.WinFormsDispatching.#ctor(System.ComponentModel.ISynchronizeInvoke)">
            <summary>
            Constructs the dispatcher provider.
            </summary>
            <param name="dispatcher">UI control e.g. WinForm which represents the thread where invokes shall be routed.</param>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.WinFormsDispatching.GetDispatcher">
            <summary>
            Returns the thread dispatcher which routes invokactions into the WinForms UI thread.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.NamespaceDoc">
            <summary>
            Receiving messages and events according to specified thread mode. 
            </summary>
            <remarks>
            Threading dispatching allows to specify in which threads received messages shall be received.  
            E.g. you can specify that events like messageReceived, connectionOpened, connectionClosed, ... will be raised in the main UI thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Threading.NamespaceGroupDoc">
            <summary>
            Routing of received messages and events into right thread.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.NamespaceGroupDoc">
            <summary>
            Communication framework.
            </summary>
        </member>
        <member name="T:ReadOnlyDictionary`2">
            <summary>
            Provides the base class for a generic read-only dictionary.
            </summary>
            <typeparam name="TKey">
            The type of keys in the dictionary.
            </typeparam>
            <typeparam name="TValue">
            The type of values in the dictionary.
            </typeparam>
            <remarks>
            <para>
            An instance of the <b>ReadOnlyDictionary</b> generic class is
            always read-only. A dictionary that is read-only is simply a
            dictionary with a wrapper that prevents modifying the
            dictionary; therefore, if changes are made to the underlying
            dictionary, the read-only dictionary reflects those changes. 
            See <see cref="T:System.Collections.Generic.Dictionary`2"/> for a modifiable version of 
            this class.
            </para>
            <para>
            <b>Notes to Implementers</b> This base class is provided to 
            make it easier for implementers to create a generic read-only
            custom dictionary. Implementers are encouraged to extend this
            base class instead of creating their own. 
            </para>
            </remarks>
        </member>
        <member name="M:ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the
            <see cref="T:ReadOnlyDictionary`2" /> class that wraps
            the supplied <paramref name="dictionaryToWrap"/>.
            </summary>
            <param name="dictionaryToWrap">The <see cref="T:IDictionary`2" />
            that will be wrapped.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the dictionary is null.
            </exception>
        </member>
        <member name="P:ReadOnlyDictionary`2.Count">
            <summary>
            Gets the number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.
            </summary>
            <value>The number of key/value pairs.</value>
            <returns>The number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</returns>
        </member>
        <member name="P:ReadOnlyDictionary`2.Keys">
            <summary>Gets a collection containing the keys in the
            <see cref="T:ReadOnlyDictionary{TKey,TValue}"></see>.</summary>
            <value>A <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/> 
            containing the keys.</value>
            <returns>A
            <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/>
            containing the keys in the
            <see cref="T:System.Collections.Generic.Dictionary`2"></see>.
            </returns>
        </member>
        <member name="P:ReadOnlyDictionary`2.Values">
            <summary>
            Gets a collection containing the values of the
            <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <value>The collection of values.</value>
        </member>
        <member name="P:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IsReadOnly">
            <summary>Gets a value indicating whether the dictionary is read-only.
            This value will always be true.</summary>
        </member>
        <member name="P:ReadOnlyDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the dictionary
            is synchronized (thread safe).
            </summary>
        </member>
        <member name="P:ReadOnlyDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to dictionary.
            </summary>
        </member>
        <member name="P:ReadOnlyDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <returns>
            The value associated with the specified key. If the specified key
            is not found, a get operation throws a 
            <see cref="T:System.Collections.Generic.KeyNotFoundException" />,
            and a set operation creates a new element with the specified key.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            The property is retrieved and key does not exist in the collection.
            </exception>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Add(`0,`1)">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="key">
            The object to use as the key of the element to add.</param>
            <param name="value">
            The object to use as the value of the element to add.</param>
        </member>
        <member name="M:ReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the <see cref="T:ReadOnlyDictionary`2" />
            contains the specified key.</summary>
            <returns>
            True if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, false.
            </returns>
            <param name="key">The key to locate in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Remove(`0)">
            <summary>
            This method is not supported by the <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            True if the element is successfully removed; otherwise, false.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the value
            associated with the specified key, if the key is found;
            otherwise, the default value for the type of the value parameter.
            This parameter is passed uninitialized.</param>
            <returns>
            <b>true</b> if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to add to the <see cref="T:ICollection`1"/>.
            </param>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Clear">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:ICollection`1"/> contains a
            specific value.
            </summary>
            <param name="item">
            The object to locate in the <see cref="T:ICollection`1"/>.
            </param>
            <returns>
            <b>true</b> if item is found in the <b>ICollection</b>; 
            otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the ICollection to an Array, starting at a
            particular Array index. 
            </summary>
            <param name="array">The one-dimensional Array that is the
            destination of the elements copied from ICollection.
            The Array must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to remove from the ICollection.
            </param>
            <returns>Will never return a value.</returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>. 
            </summary>
            <param name="array">
            The one-dimensional Array that is the destination of the elements copied from 
            ICollection. The Array must have zero-based indexing.
            </param>
            <param name="index">
            The zero-based index in Array at which copying begins.
            </param>
        </member>
        <member name="T:System.NamespaceDoc">
            <summary>
            Missing functionality across various .NET platforms.
            </summary>
        </member>
    </members>
</doc>
